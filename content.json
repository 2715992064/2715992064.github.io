{"meta":{"title":"Cedeat的摸鱼中心","subtitle":"Cedeat的摸鱼中心","description":"编程小白的记录，来看看吧~","author":"Cedeat","url":"http://2715992064.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-28T05:41:56.419Z","updated":"2022-02-28T05:41:39.412Z","comments":true,"path":"baidu_verify_code-6whQLFjAsC.html","permalink":"http://2715992064.github.io/baidu_verify_code-6whQLFjAsC.html","excerpt":"","text":"6bdc6aa9db340950b5c9b8018f40dcfc"},{"title":"about","date":"2021-12-14T05:30:20.000Z","updated":"2021-12-14T05:30:36.794Z","comments":true,"path":"about/index.html","permalink":"http://2715992064.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-14T05:28:11.000Z","updated":"2021-12-14T05:28:43.848Z","comments":true,"path":"categories/index.html","permalink":"http://2715992064.github.io/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2021-09-27T12:43:30.000Z","updated":"2021-12-14T05:31:15.993Z","comments":true,"path":"404/index.html","permalink":"http://2715992064.github.io/404/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-12-14T05:31:46.000Z","updated":"2021-12-14T05:32:01.549Z","comments":true,"path":"contact/index.html","permalink":"http://2715992064.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-02-11T12:41:49.000Z","updated":"2022-02-11T12:42:12.187Z","comments":true,"path":"friends/index.html","permalink":"http://2715992064.github.io/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-14T05:29:24.000Z","updated":"2021-12-14T05:29:43.471Z","comments":true,"path":"tags/index.html","permalink":"http://2715992064.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线段树","slug":"线段树","date":"2022-05-02T16:00:00.000Z","updated":"2022-05-04T06:54:04.538Z","comments":true,"path":"2022/05/03/xian-duan-shu/","link":"","permalink":"http://2715992064.github.io/2022/05/03/xian-duan-shu/","excerpt":"","text":"线段树总结线段树的五大操作 ： build（建树），modify（修改），query（查询），pushup（自底向上维护父子节点关系，类似于更新），pushdown（维护lazytag），方便日后查询。 pushup一般不会太过复杂，主要维护父子节点的关系，根据题意维护即可。 void pushup(int u) { tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; } // 父节点的区间和等于左右儿子的区间和。 void pushup(int u) { tr[u].v = max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v); } // 父节点的最大值等于左右儿子的最大值。 pushdownpushdown操作主要是用于维护lazytag，表示下传lazytag。 主要分为三步 1.判断是否含有lazytag 2.令左右节点的值按照lazytag进行修改，并下传lazytag至左右节点 3.将当前节点的lazytag置空 注意： 1.我们此处lazytag的含义是 当前节点含有lazytag，并且区间已经修改过，因此在下传时要先更新区间值。 2.lazytag的核心是延迟修改，所以只在modify和query操作完全包含区间时才不会下传，当不完全包含区间时，表示我们必须要向下寻找剩余的区间，那么再向下的区间就不得不修改，因此要先进行pushdown void pushdown(int u) // 例为维护区间加的lazytag { auto &amp;r = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1]; if (r.add){ left.add += r.add, left.sum += (left.r - left.l + 1) * r.add; right.add += r.add, right.sum += (right.r - right.l + 1) * r.add; r.add = 0; } } buildvoid build (int u, int l, int r) { if (l == r) tr[u] = {l, r, q[r]}; else { tr[u] = {l, r, q[r], 0}; // 该节点的左端点，右端点，以及维护的值和lazytag（可以不为1） int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); // 向左下递归建树 build(u &lt;&lt; 1 | 1, mid + 1, r); // 向右下递归建树 pushup(u); // 最后自底向上更新节点所维护的值 } } modify单点修改 void modify(int u, int x, int v) // x为待修改的数的下标，v为修改后的值 { if (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v; // 修改 else{ // 未达到就继续递归 int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); // 修改后自底向上更新一下。 } } 区间修改 含lazytag操作的区间修改，我们需要首先判断： 1.如果当前节点的区间被完全包含在所找的区间内，那么不再继续向下寻找，更新当前节点的值，打上lazytag，到此为止。 2.如果不完全包含，那么先下传标记（如果有标记），再左右递归，直到完全包含（只有一个也算）。最后再向上更新。 void modify(int u, int l, int r, int d) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) { tr[u].sum += (tr[u].r - tr[u].l + 1) * d; tr[u].add += d; } else { pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d); pushup(u); } } queryquery操作就相对直白，分为以下几步 1.如果当前节点被完全包含查询区间时，那么直接返回节点值 2.否则就先下传lazytag，再递归左右儿子分别求和，要注意lr和tr[u].l, tr[u].r的区别。 int query(int u, int l, int r) { if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; pushdown(u); int mid = tr[u].l + tr[u].r &gt;&gt; 1; int sum = 0; if (l &lt;= mid) sum += query(u &lt;&lt; 1, l, r); if (r &gt; mid) sum += query(u &lt;&lt; 1 | 1, l, r); return sum; }","categories":[{"name":"算法进阶","slug":"算法进阶","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Cedeat"},{"title":"BFS优化","slug":"BFS优化","date":"2022-04-29T16:00:00.000Z","updated":"2022-05-02T10:55:28.084Z","comments":true,"path":"2022/04/30/bfs-you-hua/","link":"","permalink":"http://2715992064.github.io/2022/04/30/bfs-you-hua/","excerpt":"","text":"BFS优化双端队列广搜在普通BFS中，我们默认边权为1，仅当在这个情况下，我们才能够找到最短路，而当边权不为1时，我们就要考虑最短路算法。双端队列广搜就是利用BFS的两端性，来对边权分别为1或0的点进行BFS，使其仍找到最短路。 BFS具有两端性，即在我们进行BFS的过程中，我们的队列只存在两个值，一个是当前走到的距离d，另一个是通过当前距离，然后push到队列里的新的距离d+1，针对这个特点，我们可以用双端队列进行BFS，从而在队尾push d+1的值，在队头push d的值，这样就不影响BFS的顺序了。 175. 电路维修 - AcWing题库 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;deque&gt; using namespace std; #define x first #define y second typedef pair&lt;int, int&gt; PII; const int maxn = 510; int n, m; char g[maxn][maxn]; int dist[maxn][maxn]; bool st[maxn][maxn]; int bfs() { memset(dist, 0x3f, sizeof dist); memset(st, 0, sizeof st); dist[0][0] = 0; deque&lt;PII&gt; q; q.push_back({0, 0}); char cs[] = \"\\\\/\\\\/\"; int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1}; int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1}; while (q.size()) { auto t = q.front(); q.pop_front(); if (st[t.x][t.y]) continue; st[t.x][t.y] = 1; for (int i = 0; i &lt; 4; i ++ ) { int a = t.x + dx[i], b = t.y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 0 &amp; b &lt;= m) { int ca = t.x + ix[i], cb = t.y + iy[i]; int d = dist[t.x][t.y] + (g[ca][cb] != cs[i]); if (d &lt; dist[a][b]) { dist[a][b] = d; if (g[ca][cb] != cs[i]) q.push_back({a, b}); // 双端队列的特性，对距离为d+1的入队尾，对距离为d的入队头。 else q.push_front({a, b}); } } } } return dist[n][m]; } int main () { int tt; cin &gt;&gt; tt; while (tt -- ) { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) scanf(\"%s\", g[i]); int t = bfs(); if (t == 0x3f3f3f3f) cout &lt;&lt; \"NO SOLUTION\" &lt;&lt; endl; else cout &lt;&lt; t &lt;&lt; endl; } } 双向广搜双向广搜一般用于最小步数模型中，因为最短路模型中一般搜到的点都不多。而在最小步数模型中，有可能发生TLE或MLE。 双向广搜指的是同时从起点和终点进行BFS，直到他们的状态相等为止，可以理解为首尾双向奔赴。在双向广搜中有一个常用的优化，即每次优先搜索队列状态较小的部分，比如首.size &lt; 尾.size，我们要对首队列进行搜索。 190. 字串变换 - AcWing题库 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int maxn = 6; int n; string A, B; string a[maxn], b[maxn]; int extend(queue&lt;string&gt; &amp;q, unordered_map&lt;string, int&gt; &amp;da, unordered_map&lt;string, int&gt; &amp;db, string a[maxn], string b[maxn]) { int d = da[q.front()]; while (q.size() &amp;&amp; da[q.front()] == d) { auto t = q.front(); q.pop(); for (int i = 0; i &lt; n; i ++ ) { for (int j = 0; j &lt; t.size(); j ++ ) { if (t.substr(j, a[i].size()) == a[i]) { string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size()); if (db.count(r)) return da[t] + db[r] + 1; if (da.count(r)) continue; da[r] = da[t] + 1; q.push(r); } } } } return 11; } int bfs() { if (A == B) return 0; queue&lt;string&gt; qa, qb; unordered_map&lt;string, int&gt; da, db; qa.push(A), qb.push(B); da[A] = db[B] = 0; int step = 0; while (qa.size() &amp;&amp; qb.size()) { int t; if (qa.size() &lt; qb.size()) t = extend(qa, da, db, a, b); else t = extend(qb, db, da, b, a); if (t &lt;= 10) return t; if (++ step == 10) return -1; } return -1; } int main () { cin &gt;&gt; A &gt;&gt; B; while (cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++ ; int t = bfs(); if (t == -1) cout &lt;&lt; \"NO ANSWER!\" &lt;&lt; endl; else cout &lt;&lt; t &lt;&lt; endl; return 0; }","categories":[{"name":"算法进阶","slug":"算法进阶","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"http://2715992064.github.io/tags/%E6%90%9C%E7%B4%A2/"}],"author":"Cedeat"},{"title":"斜率优化DP","slug":"斜率优化DP","date":"2022-04-26T07:49:00.000Z","updated":"2022-04-30T04:26:43.227Z","comments":true,"path":"2022/04/26/xie-lu-you-hua-dp/","link":"","permalink":"http://2715992064.github.io/2022/04/26/xie-lu-you-hua-dp/","excerpt":"","text":"斜率优化DP引入 一个线性DP题300. 任务安排1 - AcWing题库 这题n只有5000的数据，n^2可做。 f[i]表示取前i个任务，且第j个任务的最后一个正好是i。 公式：$$ \\begin{align}f_i &amp;= \\min\\bigg({ f_j + S \\times \\sum_{k=j+1}^n c_k + \\sum_{k=1}^i t_k \\times \\sum_{k=j+1}^i c_k}\\bigg) \\前缀和优化：f_i &amp;= \\min\\bigg(f_j + S \\times (sc_n - sc_j) + st_i \\times (sc_i - sc_j)\\bigg)\\end{align}$$状态转移方程 f[i] = min(f[i], f[j] + sumt[i] * (sumc[i] - sumc[j]) + s * (sumc[n] - sumc[j])); 本题仅作为题意的说明及公式的推引。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define int long long const int maxn = 5010; int f[maxn], q[maxn], sumt[maxn], sumc[maxn]; int n, s; signed main () { cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i ++ ) { int t, c; cin &gt;&gt; t &gt;&gt; c; sumt[i] = sumt[i - 1] + t; sumc[i] = sumc[i - 1] + c; } memset(f, 0x3f, sizeof f); f[0] = 0; for (int i = 1; i &lt;= n; i ++ ) { for (int j = 0; j &lt; i; j ++ ) { f[i] = min(f[i], f[j] + sumt[i] * (sumc[i] - sumc[j]) + s * (sumc[n] - sumc[j])); } } cout &lt;&lt; f[n] &lt;&lt; endl; }","categories":[{"name":"算法进阶","slug":"算法进阶","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"单调队列优化DP","slug":"单调队列优化DP","date":"2022-04-25T06:49:00.000Z","updated":"2022-05-04T07:43:24.134Z","comments":true,"path":"2022/04/25/dan-diao-dui-lie-you-hua-dp/","link":"","permalink":"http://2715992064.github.io/2022/04/25/dan-diao-dui-lie-you-hua-dp/","excerpt":"","text":"单调队列优化DP单调队列优化的经典问题是滑动窗口，而滑动窗口本质上解决的问题都是移动区间内的最值问题，所以碰到此类问题我们都可以用单调队列进行优化。 纯滑动窗口问题题目链接：154. 滑动窗口 - AcWing题库 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1000010; int a[N], q[N]; // q为单调队列，需要注意，队列中存放的是数组下标。 int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; int hh = 0, tt = -1; // hh为队列头，tt为队列尾。tt &lt; hh的原因是防止在刚进入循环时判断出错，所以要将tt小于hh，从而达到先入一个数的情况。 for (int i = 0; i &lt; n; i ++ ){ // 模拟队尾碰到新数a[i]的过程 if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ; // 单调队列长度大于k，队头出队，加上hh &lt;= tt的原因主要是防止初始状态时tt &lt; hh。 while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --; // 碰到新数a[i]后，若当前队尾大于a[i]，则放入后不满足单调递减 q[ ++ tt] = i; // 新元素入队 if (i &gt;= k - 1) printf(\"%d \", a[q[hh]]); // 用单调队列维护一个单调递减的区间，故每次窗口内最大值一定是队头 } printf(\"\\n\"); // 以下同上，改为维护单调递增即可。 hh = 0, tt = -1; for (int i = 0; i &lt; n; i ++ ){ if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ; while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt --; q[ ++ tt] = i; if (i &gt;= k - 1) printf(\"%d \", a[q[hh]]); } printf(\"\\n\"); return 0; } 135. 最大子序和 - AcWing题库 考虑维护一个单调递增的前缀和的滑动窗口。 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 300010; int n, m; int s[maxn], q[maxn]; int main () { ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; s[i]; s[i] += s[i - 1]; // 前缀和 } int res = -0x3f3f3f3f; // 长度至少为1 int hh = 0, tt = 0; for (int i = 1; i &lt;= n; i ++ ) { // 枚举右端点 if (q[hh] &lt; i - m) hh ++ ; // 区间长度如果大于m，就不可以 res = max (res, s[i] - s[q[hh]]); // 更新最值 while (hh &lt;= tt &amp;&amp; s[i] &lt;= s[q[tt]]) tt -- ; // 滑动窗口开滑 q[ ++ tt ] = i; // 入队 } cout &lt;&lt; res &lt;&lt; endl; } 1088. 旅行问题 - AcWing题库 首先我们要考虑将环形问题化为一条区间。 用p[i] 表示 如图，对于顺时针遍历，如果我们可以满足条件，从3走到3，那么对于所有的k，都存在s[k] - s[i] &gt;= 0，即对图中情况，都满足s[k] - s[2] &gt;= 0，即s[k] &gt;= s[2]。所以我们只需要找到一个长度为n的滑动窗口，满足窗口内的最小值满足s[min] &gt;= s[2]，所以该题就转化为了一个区间最值问题。 同理逆时针 #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long const int maxn = 2e6 + 10; int n; int p[maxn], d[maxn]; int s[maxn]; int q[maxn]; bool st[maxn]; signed main () { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) { cin &gt;&gt; p[i] &gt;&gt; d[i]; } for (int i = 1; i &lt;= n; i ++ ) s[i] = s[i + n] = p[i] - d[i]; for (int i = 1; i &lt;= 2 * n; i ++ ) s[i] += s[i - 1]; int hh = 0, tt = -1; for (int i = 2 * n; i &gt;= 1; i -- ) { if (hh &lt;= tt &amp;&amp; q[hh] &gt; i + n - 1) hh ++ ; while (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt -- ; q[ ++ tt] = i; if (i &lt;= n &amp;&amp; s[q[hh]] &gt;= s[i - 1]) st[i] = 1; } // 逆时针 hh = 0, tt = -1; d[0] = d[n]; for (int i = 1; i &lt;= n; i ++ ) s[i] = s[i + n] = p[i] - d[i - 1]; for (int i = 2 * n; i &gt;= 0; i -- ) s[i] += s[i + 1]; for (int i = 1; i &lt;= 2 * n; i ++ ) { if (hh &lt;= tt &amp;&amp; q[hh] &lt; i - n + 1) hh ++ ; while (hh &lt;= tt &amp;&amp; s[q[tt]] &gt;= s[i]) tt -- ; q[ ++ tt] = i; if (i &gt; n &amp;&amp; s[q[hh]] &gt;= s[i + 1]) st[i - n] = 1; } for (int i = 1; i &lt;= n; i ++ ) { if (st[i]) cout &lt;&lt; \"TAK\" &lt;&lt; endl; else cout &lt;&lt; \"NIE\" &lt;&lt; endl; } } 滑动窗口+DP1089. 烽火传递 - AcWing题库 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e6 + 10, inf = -0x3f3f3f3f; int n, m, l, r; int a[maxn], f[maxn], q[maxn &lt;&lt; 1]; int main () { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; int hh = 0, tt = 0; for (int i = 1; i &lt;= n; i ++ ) { if (q[hh] &lt; i - m) hh ++ ; f[i] = f[q[hh]] + a[i]; while (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt -- ; q[ ++ tt] = i; } int res = 1e9; for (int i = n - m + 1; i &lt;= n; i ++ ) { // 答案一定在最后一段区间内选出 res = min(res, f[i]); } cout &lt;&lt; res &lt;&lt; endl; } 1090. 绿色通道 - AcWing题库 加入二分的做法。 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 500100; int n, m; int w[maxn]; int q[maxn], f[maxn]; bool check (int x) { int hh = 0, tt = 0; for (int i = 1; i &lt;= n; i ++ ) { if (q[hh] &lt; i - x - 1) hh ++ ; f[i] = f[q[hh]] + w[i]; while (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt -- ; q[ ++ tt ] = i; } for (int i = n - x; i &lt;= n; i ++ ) { if (f[i] &lt;= m) return true; } return false; } int main () { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; w[i]; int l = 0, r = n; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout &lt;&lt; l &lt;&lt; endl; } 1087. 修剪草坪 - AcWing题库 经典问题修剪草坪，我们可以把问题转化为每k+1头牛里至少选择一头，每次选择k+1内的最小值，这样就转化成了滑动窗口的裸题。 #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long const int maxn = 1000010; int q[maxn], n, m; int ans, f[maxn]; signed main () { cin &gt;&gt; n &gt;&gt; m; int alls = 0; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; f[i], alls += f[i]; int hh = 0, tt = 0; for (int i = 1; i &lt;= n; i ++ ) { if (hh &lt;= tt &amp;&amp; i - q[hh] &gt; m + 1) hh ++ ; f[i] += f[q[hh]]; while (hh &lt;= tt &amp;&amp; f[q[tt]] &gt;= f[i]) tt -- ; q[ ++ tt] = i; } for (int i = n - m; i &lt;= n; i ++ ) ans = max(ans, alls - f[i]); cout &lt;&lt; ans &lt;&lt; endl; } 二维滑动窗口1091. 理想的正方形 - AcWing题库 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; //#define int long long const int maxn = 1010, inf = 1e9; int n, m, k; int w[maxn][maxn]; int row_min[maxn][maxn], row_max[maxn][maxn]; int q[maxn]; void get_min(int a[], int b[], int tot) { int hh = 0, tt = -1; for (int i = 1; i &lt;= tot; i ++ ) { if (hh &lt;= tt &amp;&amp; q[hh] &lt;= i - k) hh ++ ; while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ; q[ ++ tt] = i; b[i] = a[q[hh]]; } } void get_max(int a[], int b[], int tot) { int hh = 0, tt = -1; for (int i = 1; i &lt;= tot; i ++ ) { if (hh &lt;= tt &amp;&amp; q[hh] &lt;= i - k) hh ++ ; while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ; q[ ++ tt] = i; b[i] = a[q[hh]]; } } signed main () { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= m; j ++ ) { cin &gt;&gt; w[i][j]; } } for (int i = 1; i &lt;= n; i ++ ) { get_min(w[i], row_min[i], m); get_max(w[i], row_max[i], m); } int res = inf; int a[maxn], b[maxn], c[maxn]; for (int i = k; i &lt;= m; i ++ ) { for (int j = 1; j &lt;= n; j ++ ) a[j] = row_min[j][i]; get_min(a, b, n); for (int j = 1; j &lt;= n; j ++ ) a[j] = row_max[j][i]; get_max(a, c, n); for (int j = k; j &lt;= n; j ++ ) res = min(res, c[j] - b[j]); } cout &lt;&lt; res &lt;&lt; endl; }","categories":[{"name":"算法进阶","slug":"算法进阶","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"杂项","slug":"杂","date":"2022-04-10T16:00:00.000Z","updated":"2022-04-30T13:08:52.442Z","comments":true,"path":"2022/04/11/za/","link":"","permalink":"http://2715992064.github.io/2022/04/11/za/","excerpt":"","text":"汉诺塔问题#include &lt;bits/stdc++.h&gt; using namespace std; void move(int n, char a, char b) { cout &lt;&lt; \"No.\" &lt;&lt; n &lt;&lt; ' ' &lt;&lt; \"disk: \" &lt;&lt; a &lt;&lt; \"-&gt;\" &lt;&lt; b &lt;&lt; endl; } void hanoi (int n, char a, char b, char c) { if (n == 1){ move(n, a, c); } else{ hanoi(n - 1, a, c, b); // 将a上面n - 1个盘子借助c移到b move(n, a, c);// 将最后一个n号盘子从a移动到c hanoi(n - 1, b, a, c); // 将b上的n - 1个盘子借助a移到c上 } } int main() { int n; cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); } 约瑟夫环#include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1001000; int tt; int n, k; int q[maxn]; void solve() { cin &gt;&gt; n &gt;&gt; k; q[1] = 0; for (int i = 2; i &lt;= n; i++) { q[i] = (q[i - 1] + k) % i; } cout &lt;&lt; q[n] + 1 &lt;&lt; endl; } signed main() { solve(); return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Cedeat"},{"title":"数字三角形模型","slug":"数字三角形","date":"2022-03-15T16:00:00.000Z","updated":"2022-03-17T07:46:13.984Z","comments":true,"path":"2022/03/16/shu-zi-san-jiao-xing/","link":"","permalink":"http://2715992064.github.io/2022/03/16/shu-zi-san-jiao-xing/","excerpt":"","text":"数字三角形模型数字三角形模型DP是线性DP的一类，有非常多的变式，不过本质是从顶部出发，向右或下走，即满足数字三角形的所有条件。 例1 Acwing898.数字三角形 标程： #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 510; int f[N][N]; int n; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= i; j ++ ){ cin &gt;&gt; f[i][j]; } } for (int i = n; i &gt;= 1; i -- ){ for (int j = i; j &gt;= 1; j -- ){ f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + f[i][j]; } // 从底向上出发，不考虑边界问题 } cout &lt;&lt; f[1][1] &lt;&lt; endl; return 0; } 例2 Acwing1015.摘花生 经典的数字三角形模型，甚至不需要考虑边界问题。 标程 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int w[N][N]; int f[N][N]; //表示走到i，j时的最大数量 int main() { int T; scanf(\"%d\", &amp;T); while (T -- ) { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) scanf(\"%d\", &amp;w[i][j]); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j]; // 状态转移方程，表示从左或上走来 printf(\"%d\\n\", f[n][m]); } return 0; } 例3 Acwing1018.最低通行费 和摘花生一题类似 标程： #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 110; int q[maxn][maxn]; int f[maxn][maxn]; int n; int main() { memset(f, 0x3f, sizeof f); // 初始化为inf，因为我们要取得是min cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= n; j ++ ) cin &gt;&gt; q[i][j]; } f[1][1] = q[1][1]; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= n; j ++ ){ f[i][j] = min({f[i][j], f[i - 1][j] + q[i][j], f[i][j - 1] + q[i][j]}); } } cout &lt;&lt; f[n][n] &lt;&lt; endl; } 例4 Acwing1027.方格取数 相对麻烦的数字三角形模型，因为需要找两条路径。 一种可行的办法是先走一条路，存下走过的路径，清零后再找一次第二条路。 还有一种方法，我们可以同时走两条路，多开几个状态来表示两条路。这样的话，最直观的方法是用四个状态维护i1,i2,j1,j2，进行状态转移。 不过我们可以得到 i1 + j1 = i2 + j2 的方程，即可设i1 + j1 = k，那么用三维即可满足所有的状态。 j1 = k - i1, j2 = k - i2; 标程： #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 15; int q[maxn][maxn]; int f[maxn * 2][maxn][maxn]; int a, b, c; int n; int main() { cin &gt;&gt; n; while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) q[a][b] = c; for (int k = 2; k &lt;= 2 * n; k ++ ){ for (int i1 = 1; i1 &lt;= n; i1 ++ ){ for (int i2 = 1; i2 &lt;= n; i2 ++ ){ int j1 = k - i1, j2 = k - i2; if (j1 &gt;= 1 &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= 1 &amp;&amp; j2 &lt;= n){ int t = q[i1][j1]; if (i1 != i2) t += q[i2][j2]; int &amp;x = f[k][i1][i2]; x = max(x, f[k - 1][i1 - 1][i2 - 1] + t); x = max(x, f[k - 1][i1][i2 - 1] + t); x = max(x, f[k - 1][i1 - 1][i2] + t); x = max(x, f[k - 1][i1][i2] + t);//四种状态转移方程 } } } } cout &lt;&lt; f[2 * n][n][n] &lt;&lt; endl; }","categories":[{"name":"算法进阶","slug":"算法进阶","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"树状数组维护区间和/最值","slug":"树状数组","date":"2022-02-17T16:00:00.000Z","updated":"2022-02-18T13:52:42.455Z","comments":true,"path":"2022/02/18/shu-zhuang-shu-zu/","link":"","permalink":"http://2715992064.github.io/2022/02/18/shu-zhuang-shu-zu/","excerpt":"","text":"–2022.2.18更新树状数组维护区间最值 树状数组维护区间和/最值假设给定我们一个数组，让我们进行单点修改和区间查询操作，则需要O（1）和O（n）的时间复杂度，多次修改查询的总复杂度最坏为O（n^2），而用树状数组进行这些操作的时间复杂度仅有O（logn），总最坏时间复杂度为O（nlogn）。 引入-lowbit操作lowbit（x）非负整数x在二进制表示下最低位1及其后面的0构成的数值。 例如 lowbit(44) = lowbit(101100) = (100) = 4; 一个数x(101100)将其取反后(010011)在加一(010100)后，我们可以观察到，在二进制上除最低位1及其后面的0，其余所有位都取反了，此时我们再与原数进行按位与操作，就能得到x的lowbit。 计算机在存储时用的是补码而非反码，因此在编译器中的-x表示的就是x取反后加一，因此： lowbit(X) = x &amp; -x; 树状数组维护区间和 我们在一个数组a上建立以上的树形结构，每个节点t[x]保存以x为根的子树中叶结点值的和。 t[x]节点覆盖的长度即为lowbit(x)。 t[x]节点的父节点为t[x + lowbit(x)]。 单点修改操作 &amp; 建立树状数组 可见，我们修改一个点，也要修改其上的父节点，最坏的时间复杂度为O(logn) void add(int x, int k){ for (; x &lt;= n; x += x &amp; -x) t[x] += k; } 如何建立树状数组？有了单点修改的操作，我们只需要在读入时对每个t[i]进行add操作即可 for (int i = 1; i &lt;= n; i ++ ){ int x; cin &gt;&gt; x; add(i, a); } 区间查询操作 而对于区间查询（以7为例），我们要同时加上t[7], t[6],t[4]（即覆盖了a[1]~a[7]的所有t[x])。 int ask(int x){ int ans = 0; for (; x; x -= x &amp; -x) ans += t[x]; return ans; } //单点修改与区间查询 #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long int n, p; int q[1123456], t[1123456]; inline int lowbit(int x) { return x &amp; -x; } void add(int x, int k) { for (; x &lt;= n; x += lowbit(x)) t[x] += k; } int ask(int x) { int ans = 0; for (; x; x -= lowbit(x)) ans += t[x]; return ans; } signed main() { cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= n; i ++ ){ cin &gt;&gt; q[i]; add(i, q[i]); } while (p -- ){ int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) add(x, y); if (op == 2) cout &lt;&lt; ask(y) - ask(x - 1) &lt;&lt; endl; } return 0; } 区间修改与单点查询要将一个区间内同时加上一个数k，或查询当前的第i个数，我们需要新的操作。 注意初始化树状数组时b[i] = q[i] - q[i - 1]; //区间修改与单点查询 #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long int n, p; int q[1123456], t[1123456]; inline int lowbit(int x) { return x &amp; -x; } void add(int x, int k) { for (; x &lt;= n; x += lowbit(x)) t[x] += k; } int ask(int x) { int ans = 0; for (; x; x -= lowbit(x)) ans += t[x]; return ans; } signed main() { cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= n; i ++ ){ cin &gt;&gt; q[i]; add(i, q[i] - q[i - 1]); } while (p -- ){ int op, l, r, x; cin &gt;&gt; op; if (op == 1){ cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; add(l, x), add(r + 1, -x); } if (op == 2){ cin &gt;&gt; x; cout &lt;&lt; ask(x) &lt;&lt; endl; } } return 0; } 区间修改与区间查询 如图，我们仍用树状数组维护差分数组b的前缀和，区间查询的值即为蓝色部分，我们可以发现蓝色部分不方便计算，因此构建一个大矩形（红色），再减去不计算的部分（黄色），这一部分我们可以维护另外一个i*b[i]的前缀和数组。 //区间修改与区间查询 #include &lt;bits/stdc++.h&gt; using namespace std; #define int long long int n, p; int q[1123456], t[1123456], s[1123456], sum[1123456]; inline int lowbit(int x) { return x &amp; -x; } void add1(int x, int k) { for (int i = x; i &lt;= n; i += lowbit(i)) t[i] += k, s[i] += x * k; } int ask1(int x) { int ans = 0; for (int i = x; i; i -= lowbit(i)) ans += (x + 1) * t[i] - s[i]; return ans; } signed main() { cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= n; i ++ ){ cin &gt;&gt; q[i]; sum[i] = q[i] + sum[i - 1]; add1(i, q[i] - q[i - 1]); } while (p -- ){ int op, l, r, x; cin &gt;&gt; op; if (op == 1){ cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; add1(l, x), add1(r + 1, -x); } if (op == 2){ cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; ask1(r) - ask1(l - 1) &lt;&lt; endl; } } return 0; } 本篇题解图片来自〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作 个人认为讲的很详细。 树状数组维护最大值用树状数组维护最大值。同样可以让每个节点t[x]保存以x为根的子树中叶结点值的最大值，对于维护的最大值，我们同样可以进行单点修改和区间查询操作。 单点修改由之前维护区间和的单点修改操作，我们很容易想到： void add(int x, int k){ // 将q[x]变为k for (; x &lt;= n; x += lowbit(x)) t[x] = max(t[x], k); } 这段代码是由前面树状数组维护区间和里单点操作修改而成，仅将t[x]+=k 变为 t[x] = max(t[x], k)。 那么这段代码是否可行呢？ 如果我们要将这个数变大，即k &gt;= q[x]，那么这段代码是没有问题的，t[x]每次都会更新，然后往上一步步寻找。但想一下，如果k &lt; q[x]，并且q[x]恰好是t[x]覆盖范围内唯一的最大值，那么我们要将q[x]变小，其范围内最大值，即t[x]也一定会变小，但这个max操作并不会将t[x]变小，因此这样的单点修改是不可行的。 唯一的方法，是连同q[x]和t[x]一起更新，不进行max操作，然后往上找相关的数继续更新。 还是该图，我们想一下，与t[8]直接相关的有几个数？ 很容易观察到： t[8] = max({a[8], t[4], t[6], t[7]}); 我们转化为二进制观察： t[1000] = max({a[1000], t[100], t[110], t[111]}); 这里我们直接给出公式： t[i] = max({q[i], t[i - lowbit(i)/(2^1)], t[i - lowbit[i]/(2^2)]...t[i - 2^0]}); 代码： void update(int x, int k){ // 将q[x]变为k q[x] = k; // 将原数组也改变，可加可不加 for (; x &lt;= n; x += lowbit(x)){ t[x] = k; // 直接更新 for (int i = 1; i &lt; lowbit(x); i &lt;&lt;= 1) t[x] = max(t[x], t[x - i]);//公式 } } 区间查询查询区间[l, r]的最大值，需要用上原数组。 区间查询的过程我们主要用分类讨论解决。 如果 r - lowbit(r) + 1 &gt;= l, ans = max(query(l, r - lowbit(r)), t[r]); 否则 res = max(query(l, r - 1), q[r]); 直接看代码吧，不难理解： int query(int l, int r) { int ans = 0; while (r &gt;= l){ ans = max(q[r], ans), r -- ; for (; r - lowbit(r) &gt;= l; r -= lowbit(r)) ans = max(t[r], ans); } return ans; } 尾部添数树状数组维护最大值支持向区间尾部添加一个值。 void add(int x) { q[ ++ tot] = x; t[tot] = max(q[tot], query(tot + 1 - lowbit(tot), tot - 1)); }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Cedeat"},{"title":"C++STL","slug":"STL","date":"2022-02-10T16:00:00.000Z","updated":"2022-02-12T09:21:42.822Z","comments":true,"path":"2022/02/11/stl/","link":"","permalink":"http://2715992064.github.io/2022/02/11/stl/","excerpt":"","text":"常用C++STL向量（vector）容器变长数组，使用倍增的思想。 初始化vector &lt;int&gt; a; // 普通初始化 vector &lt;int&gt; a(10); // 定义长度 vector &lt;int&gt; a(10, 3); // 将长度为10的vector全部初始化为3 vector &lt;int&gt; a[10] // vector数组，表示定义10个vector 函数a.size() || a.length // 返回vector内元素的个数 a.empty() // 返回ture或false，判断是否为空 a.clear() // 清空 a.front() || a.back() // 返回第一个/最后一个数 a.push_back() || a.pop_back() // 队尾插入一个数/队尾删除一个数 a.begin() || a.end() // vector的迭代器 遍历for (int i = 0; i &lt; n; i ++ ) a.push_back(i); // 下标遍历 for (auto i = a.begin(); i != a.end(); i ++ ) cout &lt;&lt; *i &lt;&lt; ' '; // 迭代器遍历 for (auto x : a) cout &lt;&lt; x &lt;&lt; ' '; // 范围遍历 比较运算vector同样可以用来进行比较运算，比较的方式是通过字典序进行比较。 pair二元组pair &lt;type, type&gt; p; pair的取得方式，第一个元素为 p.frist()，第二个为p.second() pair同样也支持比较运算，以frist为第一关键字，second为第二关键字，进行字典序比较。 初始化p = make_pair(10, \"abc\"); p = {20, \"abc\"}; 若要用pair存储两个以上的元素，也可以这样定义 pair&lt;int, pair&lt;int, int&gt;&gt; p; 字符串string初始化string a = \"abc\"; a += \"bcd\"; // string可以在字符串后加上一个字符串或字符。 函数a.size(); // 长度 a.empty(); // 判断空 a.clear(); // 清空 a.substr(x, y); // a的从x起始，长度为y的字串，若其后字串长度不满y，则到末尾为止。 a.substr(x); // 从x起始，末尾中止的字串. printf(\"%s\\n\", a.c_str()); // string首元素的地址。 队列queue，优先队列priority_queuequeue函数push() // 向队尾插入元素 front() || back() // 返回队头/队尾元素 pop() // 弹出队头元素 size() // 长度 empty() // 判断是否为空 q = queue&lt;int&gt;() // 清空queue priority_queue优先队列（堆）push() // 插入元素 top() // 返回堆顶元素 pop() // 弹出堆顶元素 优先队列默认为大根堆，如果我们想定义小根堆，有两种方式 （1）heap.push(-x) 插入-x （2）priority_queue&lt;, vector, greater&gt; heap; 栈stack函数push() // 栈顶插入元素 top() // 返回栈顶元素 pop() // 弹出栈顶元素 size(); empty(); 双端队列deque双端队列可以看作是加强版的vector，可以从队头和队尾进行插入和删除操作。不过因为效率太低，一般不使用。 size() empty() clear() front() / back() push_back() / pop_back() push_front / pop_front() begin()/end() []","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Cedeat"},{"title":"二分图（二部图）","slug":"二部图（二分图）","date":"2022-02-10T16:00:00.000Z","updated":"2022-02-12T09:20:55.179Z","comments":true,"path":"2022/02/11/er-bu-tu-er-fen-tu/","link":"","permalink":"http://2715992064.github.io/2022/02/11/er-bu-tu-er-fen-tu/","excerpt":"","text":"二部图（二分图）什么是二分图对于一个无向图G=(V,E)，如果将顶点V分隔为两个互不相交的子集（A,B），且图中的每条边（i，j）所关联的两个顶点分别属于两个不同的顶点集（i in A，j in B），则称图G为一个二分图。 二分图有一个重要的性质，即图中不含奇数环，这是二分图成立的充要条件。 二分图不一定是连通图。 染色法判断二分图判断一个无向图是否是二分图，通常使用染色法。 染色法的实现思路（DFS）：1.用1，2代表两个颜色，0代表未染色，任选一个点染成1或2 2.遍历所有点，每次将未染色的点进行dfs 3.若染色失败即break/return #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100010, M = 200010; int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++; } bool dfs(int u, int c) { color[u] = c; // 染色 for (int i = h[u]; i != -1; i = ne[i]){ int j = e[i]; if (!color[j]){ if (!dfs(j, 3 - c)) return false; // 如果在dfs递归的过程中出现染色失败，则整个图都不是二分图 } else if (color[j] == c) return false; // 如果一条边的两端点同种颜色，则染色失败 } return true; // 无染色错误则染色成功 } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ){ int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b), add(b, a); } bool flag = true; for (int i = 1; i &lt;= n; i ++ ){ // 遍历所有点，因为二分图不一定是连通图 if (!color[i]){ if (!dfs(i, 1)){ flag = false; break; } } } if (flag) printf(\"Yes\\n\"); else printf(\"No\"); return 0; } 我在写时遇到一个问题 if (!color[j]){ if (!dfs(j, 3 - c)) return false; 为何不能改成 if (!color[j]){ dfs(j, 3 - c); 这样改来，我以为在判断该点没有染色的时候，dfs只是为了染色，根本的判断染色失败在下面的一行判断中，所以这样更换没有问题，但实则不然。 这个dfs的作用不只是为了染色，也是利用dfs的返回值，判断在递归过程中是否产生了染色错误。而不加这个判断，只能判断u是否处于奇数环中，而u不一定处于奇数环，所以有可能判断错误。 二分图的最大匹配（匈牙利算法）匹配：在图论中一个匹配是指一个边的集合，其中任意两条边都没有公共顶点。 最大匹配，一个图所有匹配中，所含匹配边数最多的匹配称为最大匹配。 匈牙利算法的过程1.从左集合依次找右集合的点，如果有右集合的点还没有被匹配，就把它们连上一条边。 2.如果左集合中某一点找到的右集合中一点已经匹配过，那么就从该右集合点反找它匹配的左集合点，并找该左集合点有没有别的右集合点可以连，如果有，则连接这个右集合点，原右集合点与新左集合点相连。 虽然二分图是无向图，但匈牙利算法只需要从左边集合找右边集合，因此我们只存一条边也可以。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 510, M = 100010; int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; bool st[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]){ int j = e[i]; if (!st[j]){ st[j] = true; if (match[j] == 0 || find(match[j])){ match[j] = x; return true; } } } return false; } int main() { scanf(\"%d%d%d\", &amp;n1, &amp;n2, &amp;m); memset(h, -1, sizeof h); while (m -- ){ int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); } int res = 0; for (int i = 0; i &lt;= n1; i ++ ){ memset(st, false, sizeof st); if (find(i)) res ++; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 为什么要开st数组？为什么要memset？假设我们找到左1与右1相连，左2也欲与右1相连，于是返回左1再次查找，在查找过程中我们会一直进入find(match[1])的递归过程中。 如果加了st数组呢？在返回左1之前我们就将右1设为true，在返回左1后就不会再判断右1，因为左1已经与右1相连，也即是说，每次返回左边寻找之前都会将这个左点相连的右点设定一次，避免重复查找。而对于不同的左点，每次重新开始找都要初始化一次st数组。","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论/搜索","slug":"图论-搜索","permalink":"http://2715992064.github.io/tags/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2/"}],"author":"Cedeat"},{"title":"堆","slug":"堆","date":"2022-02-10T16:00:00.000Z","updated":"2022-02-12T09:20:04.600Z","comments":true,"path":"2022/02/11/dui/","link":"","permalink":"http://2715992064.github.io/2022/02/11/dui/","excerpt":"","text":"堆堆的结构：一颗完全二叉树（十分平衡，除最后一层（叶结点）以外，其他节点均非空，最后一层从左到右依次排布）。 小根堆也指最小堆。经过排序的完全二叉树，其中每一个非终端节点均小于其左右子节点，其根节点为所有元素的最小值。 大根堆同理。 存储方式用一维数组维护堆状数据结构。 一号点为根节点。下标为x的节点，其左节点下标为2 * x，右节点下标为2 * x + 1。 基本操作1.向下调整（down操作）:若将一个数变大，则须将这个节点下移。以小根堆为例，将一个节点下移，则需要判断它与左右子节点的大小关系，并将它与（自己，左节点，右节点）三个数中的最小值交换。 void down(int u) { int t = u; // 定义t，用来寻找三个数中最小值的下标。 if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[u]) t = u * 2; // 判断左节点是否存在，且左节点是否更小。 if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[u]) t = u * 2 + 1; // 同上，判断右节点。 if (t != u) // 需要操作 { swap(h[u], h[t]); down (t); // 递归操作，直到u为当前三个数的最小值。 } } 2.向上调整（up操作）：同理，要将一个数变小，则需将这个节点上移，对于小根堆，上移操作仅需跟它的父节点比较即可。 void up(int u) { while (u / 2 &amp;&amp; h[u / 2] &gt; h[u]){ swap(h[u / 2], h[u]); u /= 2; }// 迭代操作，当为头节点或不能再向上时结束。 } 3.插入一个数：将该数插入到整个堆的最后一个位置，然后进行up操作。 heap[++ size] = x; up(size); 4.删除任意一个元素：对于一维数组，删除数组的尾部非常简单，令size–即可，但若要删除中间元素，则需要整体改变下标的位置。 假设我们现在要删除第k个节点，只需将第k个节点变为最后一个节点，然后再删除最后一个节点。最后，对k节点进行down操作或up操作（因为此处第k个节点被赋给了最后一个结点的值），为了不用再进行判断，我们让k节点都进行up和down操作（不用担心会额外进行操作，当满足条件时，up操作和down操作只会执行其一）。 heap[k] = heap[size]; size -- ; down(k); up(k);// 删除头节点，将K改为1即可。 5.求集合中的最小（大）值：对堆来说，最值即为根结点。 heap[1]; //大根堆为最大值，小根堆为最小值。 6.修改任意一个元素：将要修改的元素（k节点）修改后，再进行一次up操作和down操作。 heap[k] = x; down(k); up(k); 7.堆的构建如果我们将n个元素每个都进行一次down操作，则时间复杂度为O（nlogn），也可通过优化，将复杂度改为O(n)。 堆的最后一层至多有n / 2个元素，如果我们要对所有元素进行down操作，则只需要对倒数第二层以上进行down操作，在对倒数第二层进行down操作时，也会保证处理到最后一层的元素，这样，我们就只须处理n / 2个数据，时间复杂度变为O(n)。 for (int i = n / 2; i ; i -- ) down(i); 进阶：堆的映射：当我们把上述所提到的删除和修改第K个节点改为删除和修改第K个插入的数，就会变成更复杂的情况。 在这里我们需要额外开两个数组ph[N]和hp[N]，ph[k]用来存储第k个插入的数在堆中的下标，但仅有此并不够，当我们在进行up或down操作时，堆中的值会改变。 举个例子，当第5个插入的数在堆中的下标为3，其子节点在堆中的下标为6。那么ph[5]即为3，但此时小根堆是不稳定的，如果我们要进行一次down操作，会将heap[3]和heap[6]的值进行交换，此时第5个插入的数，即ph[5]就会改变。一句话来说，单单用ph数组对堆进行映射是单向的关系。 为了解决这种情况，我们另设一个数组hp[N]用来表示，第k个插入的数在堆中的下标在ph数组中的值。也就是说，用此数组将堆中的下标映射与ph数组，从而达到双向的关系。 ph数组与hp数组互为反函数。即ph[j] = k, hp[k] = j; 有这两个工具，我们就可以将down和up操作中的swap函数进行“升级”，即不仅仅改变堆中的两个值，他们所对应的插入关系也应该交换。 void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } 堆排序完整代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100010; int n, m; int h[N], cnt; void down(int u) { int t = u; if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t){ swap(h[u], h[t]); down(t); } } void up (int u) { while (u / 2 &amp;&amp; h[u / 2] &gt; h[u]){ swap(h[u], h[u / 2]); u &gt;&gt;= 1; } } int main() { scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;h[i]); cnt = n; for (int i = n / 2; i ; i --) down(i); while (m -- ){ printf(\"%d \", h[1]); h[1] = h[cnt -- ]; down(1); } return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Cedeat"},{"title":"最小生成树","slug":"最小生成树","date":"2022-02-10T16:00:00.000Z","updated":"2022-02-12T09:21:16.357Z","comments":true,"path":"2022/02/11/zui-xiao-sheng-cheng-shu/","link":"","permalink":"http://2715992064.github.io/2022/02/11/zui-xiao-sheng-cheng-shu/","excerpt":"","text":"最小生成树什么是最小生成树？设定一个n点m条边的无向图G=(V,E)，V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。 由V中的n个顶点和E中的n-1条边构成的无向连通子图成为G的一棵生成树，其中边权之和最小的生成树成为最小生成树。 Prim算法与Dijkstra算法相似，prim算法也分为朴素版和堆优化版，而堆优化版一般使用不多。 Prim算法也分为以下几步，只不过这里的dist数组意义不同，dijkstra算法的dist数组的含义是距离起点的距离，而prim算法里的dist数组含义是距离集合的最短距离（即到集合内任何一点的距离最小值）： 1.进行n轮循环，每一轮循环中遍历所有的点，找到一个距离集合最小的点t。对于第一轮循环，因为dist全为INF，所以就是随机找一个点将dist初始化为0。 2.将找到的点t加入到集合当中，并且将生成树的总边权res更新。 3.用该点更新所有的dist。 因为这种方法一定可以遍历到所有的点，当某一个点t的dist为INF且不是第一轮时，代表这个点t与集合是不连通的，即不满足生成树的概念，不是连通的。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ){ int t = -1; for (int j = 1; j &lt;= n; j ++ ){ if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; } if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(g, 0x3f, sizeof g); while (m -- ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a][b] = g[b][a] = min(g[a][b], c); // 无向图 } int t = prim(); if (t == INF) printf(\"impossible\"); else printf(\"%d\\n\", t); return 0; } Kruskal算法Kruskal算法的思路十分简单，总体概括为以下两步。 1.将所有边按权重从小到大排序。 2.按权重大小枚举每条边ab，如果ab不连通，就将这条边加入到集合中。这部分的操作可以使用并查集来做。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100010, M = 200010, INF = 0x3f3f3f3f; int n, m; int p[N]; struct Edge { int a, b, w; }edges[M]; bool cmp(Edge a, Edge b) { return a.w &lt; b.w; } int find (int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m, cmp); for (int i = 0; i &lt;= n; i ++ ) p[i] = i; // 并查集的初始操作 int res = 0, cnt = 0; // cnt表示连通的边数 for (int i = 0; i &lt; m; i ++ ){ int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b){ p[a] = b; // 将边加入集合 res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res; } int main() { cin &gt;&gt; n&gt;&gt; m; for (int i = 0; i &lt; m; i ++ ){ int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; edges[i] = {a, b, w}; } int t = kruskal(); if (t == INF) printf(\"impossible\"); else printf(\"%d\", t); return 0; } 关于Kruskal的拓展Kruskal重构树：在进行Kruskal的过程中，我们找到不在同一集合的两个边，不再合并两个点，而是新建一个节点，将该节点作为中转连接这两个集合，用这两个节点的边权作为该点的点权。 试想，如果我们按降序排序（从大到小）排序所有的边，再建Kruskal重构树，那么我们所建立的将是一个小根堆（因为最大的边总是先入，最后进入的一定是生成树内最小的边）。我们可以应用于从u出发只经过边权不超过x的边所能到达的节点。 对于最大重构树上的某lca(u,v)，其点权表示的是从u到v中最大边权的最小值。 重构树的构建 void kruskal() { for(int i=1;i&lt;=n;++i)ff[i]=i; sort(rem+1,rem+1+m,cmp); for(int i=1;i&lt;=m;++i) { int fu=find(rem[i].u),fv=find(rem[i].v); if(fu!=fv) { val[++cnt]=rem[i].dis; // 用边权代表点权 ff[cnt]=ff[fu]=ff[fv]=cnt; // 三点都加入集合 add(fu,cnt); add(cnt,fu); // 建无向边 add(fv,cnt); add(cnt,fv); } } for(int i=1;i&lt;=cnt;++i) if(!vis[i]) { int f=find(i); dfs1(f,0); dfs2(f,f); } }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论/搜索","slug":"图论-搜索","permalink":"http://2715992064.github.io/tags/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2/"}],"author":"Cedeat"},{"title":"最短路","slug":"最短路","date":"2022-02-10T16:00:00.000Z","updated":"2022-03-04T09:41:23.442Z","comments":true,"path":"2022/02/11/zui-duan-lu/","link":"","permalink":"http://2715992064.github.io/2022/02/11/zui-duan-lu/","excerpt":"","text":"图论最短路 Dijkstra算法朴素Dijkstra算法 O(n^2)Dijkstra算法用于求节1到点n的最短路，适用于稠密图（其时间复杂度与边数m无关）。 对每个点设定一个dist，代表其距离点1的距离，初始化为无穷大，后续再进行更新。令dist[1] = 0，也就是说，此时除dist1以外，其他点的距离是不确定的。 设定一个集合s，表示已经确定最短路的点。首先对n个点，需要进行n次迭代。**1.找到一个t，t为非s集合中距离最小的点（即不确定距离的dist值最小的点）。2.将t点加入到s集合中（表示该点已经确定距离）。3.**用t更新其他点的距离。（有两种情况，1.假设t点后有一点j，j点的最短路是由t走过来的，即dist[t] +g[t] [j]是最短路径。2.j点的最短路不由t走过来，即此时的dist[j]是最短路)。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 510; int n, m; int g[N][N]; // 邻接矩阵存稠密图 int dist[N]; // 每个点距离点1的距离 bool st[N]; // 判断该点是否确定 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n; i ++ ){ // n个点循环n次 int t = -1; for (int j = 1; j &lt;= n; j ++ ){ // 找未确定的点中dist最小的点 if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } if (t == n &amp;&amp; dist[t] != 0x3f3f3f3f) return dist[t]; else if (t == n &amp;&amp; dist[t] == 0x3f3f3f3f) return -1; // 提前结束循环的优化，不加也可 st[t] = true; for (int j = 1; j &lt;= n; j ++ )// 用t更新其他未确定点的距离 dist[j] = min(dist[j], dist[t] + g[t][j]); } if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(g, 0x3f, sizeof g); while (m -- ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a][b] = min(g[a][b], c); } printf(\"%d\\n\", dijkstra()); return 0; } 堆优化Dijkstra算法 O(mlogn)适用于稀疏图，当边数m和点数n相差不多时，其时间复杂度要比O(n^2)小。而因为是稀疏图，我们的储存方式要用邻接表来存 在上面的朴素算法我们可以得到，三步中第一步找不确定距离中最小dist的复杂度为n^2， 而求最小值我们也可以用先前学过的小根堆来维护，每次取出根节点即可。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 1e6 + 10; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; int add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()){ auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; // 防止产生冗余 st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]){ int j = e[i]; if (dist[j] &gt; dist[ver] + w[i]){ dist[j] = dist[ver] + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0; } Dijkstra算法的弊端Dijkstra算法是基于贪心的思想，前提是每次走的一步都一定是最优的情况，因此并不能处理含有负权边的情况。因为当出现负权边，并不是局部最优解就是全局最优解。 Bellman_ford算法bellman_ford算法适用于含负权边的情况中，但是由于它的方法十分简单暴力，在多数情况下不如SPFA算法，但唯一的一点优势是可以利用它处理有限制边数的最短路问题。 松弛操作对于bellman_ford算法，我们默认只用它处理有显示边数k的情况。首先进行k次循环，表示走k次边，每走一次边，我们都重新更新一次能走到的dist[j]，这一点和dijkstra算法相似，称为松弛操作。bellman_ford算法的本质就是通过不断地遍历进行松弛操作来找到最小边。 dist[b] = min(dist[b], dist[a] + w); // 松弛操作 串联情况但和dijkstra算法不同的是，针对于有限制边数的最短路情况下，我们每次更新只能更新出离已经确定的点的旁边的一个点，以此来表示一次更新，否则我们更新到第三个点时会使用第二次本次更新过的点进行更新，相当于在一次迭代中进行了两次更新（可以理解为一次走两条边），当最多边数k有限时就不一定符合情况了，这种情况称为串联情况。 负环情况当存在负权边时，负环情况也有可能出现。负环情况指的是一条含有负权边的环，走完这一个环所需的总边权为负，当出现这种情况，我们就可以通过无限次的走负环来让最小长度为负无穷。因此当出现负环时多数情况是无解的，即不能走到n点处。但当存在负环，但走向n点的必经之路上不存在负环，问题一样有解。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 510, M = 10010; struct Edge { int a, b ,c; }edges[M]; // 结构体存边 int n, m, k; int dist[N]; int backup[N]; // 题目有特殊的边数限制，因此在更新时只能更新上次备份，否则会出现串联 void bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i ++ ){ memcpy(backup, dist, sizeof dist); // 每次都将上次的dist存到备份里 for (int j = 0; j &lt; m; j ++ ){ auto e = edges[j]; dist[e.b] = min(dist[e.b], backup[e.a] + e.c); } } } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m ; i ++ ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; edges[i] = {a, b, c}; } bellman_ford(); if (dist[n] &gt; 0x3f3f3f3f / 2) printf(\"impossible\\n\"); else printf(\"%d\\n\", dist[n]); return 0; } 最后的判断条件是0x3f3f3f3f，目的是为了防止出现一个点还未确定最小距离(0x3f3f3f3f)，而与n点之间存在负权边，会将dist[n]更新成小于0x3f3f3f3f的值，所以不能用dist[n] == 0x3f3f3f3f判断。 SPFA算法 O(nm)Bellman_ford算法过于简单粗暴，在每次走一条边时要遍历所有的边进行更新，而多数的边都是无效更新（都是在0x3f3f3f3f左右变换，不是真正的确定长度)，也就是说，只有一个点的前驱节点变小了，该节点才会变小。 SPFA就是基于BFS的思想，对Bellman_ford算法的更新进行优化。 最短路#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100010; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while (q.size()){ int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]){ int j = e[i]; if (dist[j] &gt; dist[t] + w[i]){ dist[j] = dist[t] + w[i]; if (!st[j]){ q.push(j); st[j] = true; } } } } printf(\"%d\\n\", dist[n]); return dist[n]; } int main() { cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while (m -- ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } if (spfa() == 0x3f3f3f3f) printf(\"impossible\"); else printf(\"%d\\n\", spfa()); return 0; } 判断负权环SPFA算法同样也可以用于判断负权环的存在，这需要我们定义一个cnt数组用来存储对于走到这个点走过的边数。根据抽屉原理，当cnt[j] &gt;= n时，代表我们走到这个点共走过n条边，而n条边必定存在n+1个点，但点数只有n个，因此一定走过了相同编号的点，也必定存在负环。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2010, M = 10010; int n, m; int h[N], w[M], e[M], ne[M], idx; int dist[N], cnt[N]; bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; } bool spfa() { queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ){ st[i] = true; q.push(i); } while (q.size()){ int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]){ int j = e[i]; if (dist[j] &gt; dist[t] + w[i]){ dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return true; //if (!st[j]){ q.push(j); st[j] = true; //} } } } return false; } int main() { cin &gt;&gt; n &gt;&gt; m; memset (h, -1, sizeof h); while (m -- ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); } if (spfa()) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } Floyd算法 O(n^3)用于判断多源最短路，基于动态规划的思想。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 210, INF = 1e9; int n, m, Q; int d[N][N]; void floyd() { for (int k = 1; k &lt;= n; k ++ ){ for (int j = 1; j &lt;= n; j ++ ){ for (int i = 1; i &lt;= n; i ++ ){ d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= n; j ++ ){ if (i == j) d[i][j] = 0; else d[i][j] = INF; } } while (m -- ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; d[a][b] = min(d[a][b], c); } floyd(); while (Q -- ){ int a, b; cin &gt;&gt; a &gt;&gt; b; int t =d[a][b]; if (t &gt; INF / 2) printf(\"impossible\"); else printf(\"%d\\n\", t); } return 0; } 路径还原记录一个path数组，当dist数组被更新时，就同步跟新path数组，此处以朴素dijkstra算法为例： #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 510; const int inf = 0x3f3f3f3f; int g[maxn][maxn]; int st[maxn]; int dist[500010]; int path[500010]; int n, m; int dijkstra() { memset(dist, 0x3f, sizeof dist); memset(path, -1 ,sizeof path); dist[1] = 0; for (int i = 1; i &lt;= n; i ++ ){ int t = -1; for (int j = 1; j &lt;= n; j ++ ){ if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } st[t] = 1; for (int j = 1; j &lt;= n; j ++ ){ if (dist[j] &gt; dist[t] + g[t][j]){ dist[j] = dist[t] + g[t][j]; path[j] = t; // 记录 } } } return dist[n]; } vector&lt;int&gt; get_path(int x){ vector&lt;int&gt; p; for (; x != -1; x = path[x]) p.push_back(x); reverse(p.begin(), p.end()); //p中存下的是n到1的顺序，我们逆反一下顺序。 return p; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= n; j ++ ){ g[i][j] = (i == j) ? 0 : inf; } } for (int i = 1; i &lt;= m; i ++ ){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a][b] = min(g[a][b], c); } printf(\"%d\\n\", dijkstra()); vector&lt;int&gt; p = get_path(n); for (auto it : p){ printf(\"%d \", it); } return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论/搜索","slug":"图论-搜索","permalink":"http://2715992064.github.io/tags/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2/"}],"author":"Cedeat"},{"title":"欧拉函数","slug":"欧拉函数","date":"2022-02-10T16:00:00.000Z","updated":"2022-02-11T13:37:25.757Z","comments":true,"path":"2022/02/11/ou-la-han-shu/","link":"","permalink":"http://2715992064.github.io/2022/02/11/ou-la-han-shu/","excerpt":"","text":"欧拉函数定义1~N中与N互质的数的个数称为欧拉函数，记为ϕ(N)。 若在算数基本定理中，N = p1^a1 * p2^a2 * ….. * pm^am。 ϕ(N) = N * (p1 - 1) / p1 * (p2 - 1) / p2 * …. * (pm - 1) / pm。 证明欧拉函数的证明基于容质原理。 设N = p1^a1 * p2^a2 * p3^a3 * … *pk ^ak。 我们要找到1N中与N互质的数，就要去掉1N中所有N的因数及其倍数。例如在1~N中所有p1的倍数的个数就有 N / p1个，以此类推…. 但倍数之间可能存在重复，若p1和p2的倍数之间存在重复，我们就需要减去他们的公倍数，即N / (p1 * p2)，以此类推… 最终形式：N - N / p1 - N / p2 - …. - N / pk + N / p1p2 + N / p1p3 + … - N / p1p2p3 - N / p1p2p4 - …. + N / p1p2p3….pk。 代码复杂度 O(nlogn) #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int tt; cin &gt;&gt; tt; while (tt -- ){ int x; cin &gt;&gt; x; int res = x; for (int i = 2; i &lt;= x / i; i ++ ){ if (x % i == 0){ res = res / i * (i - 1); while (x % i == 0) x /= i; } } if (x &gt; 1) res = res / x * (x - 1); cout &lt;&lt; res &lt;&lt; endl; } return 0; } 筛法求欧拉函数筛法求欧拉函数其实就是在线性筛的过程中顺便求出每个数的欧拉函数。 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1123456; typedef long long ll; bool st[maxn]; int phi[maxn], primes[maxn]; // phi[i]表示i的欧拉函数 int cnt; void get_euler(int n) { phi[1] = 1; for (int i = 2; i &lt;= n; i ++ ){ if (!st[i]){ phi[i] = i - 1; primes[cnt ++ ] = i; } for (int j = 0; primes[j] &lt;= n / i; j ++ ){ st[primes[j] * i] = 1; if (i % primes[j] == 0){ phi[primes[j] * i] = phi[i] * primes[j]; break; } else{ phi[primes[j] * i] = phi[i] * (primes[j] - 1); } } } } int main() { int n; cin &gt;&gt; n; get_euler(n); ll res = 0; for (int i = 1; i &lt;= n; i ++ ){ res += phi[i]; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 这里解释一下phi[i]如何得到。 如果i是质数：显然，一个质数k的欧拉函数就是1~k-1。 如果i不是质数：如果i % primes[j] = 0，那么primes[j] * i这个数的欧拉函数其实可以由phi[i]得到。显然primes[j]是primes[j] * i的一个质因子，且primes[j]也是i的一个质因子，那么phi[i] = i * (1 - 1 / p1) * … * (1 - 1/ primes[j]) * …，(1 - 1/ primes[j])这一项必定已经包含，而欧拉函数i乘的项数与指数大小无关，只与质因子数量有关。例如phi[6] = 6 * (1 - 1 / 2) * (1 - 1 / 3)，phi[6 ^ 100] = 6 ^ 100 * (1 - 1 / 2) * (1 - 1 / 3)。因此: phi[i] = i * (1 - 1 / p1) * ... * (1 - 1 / pk); phi[primes[j] * i] = primes[j] * i * (1 - 1 / p1) * ... * (1 - 1 / pk); phi[primes[j] * i] = primes[j] * phi[i]; // 化简 如果i % primes[j] != 0，那么 phi[i] = i * (1 - 1 / p1) * ... * (1 - 1 / pk); phi[primes[j] * i] = primes[j] * i * (1 - 1 / p1) * ... * (1 - 1 / pk) * (1 - 1 / primes[j]); phi[primes[j] * i] = phi[i] * (primes[j] - 1); // 化简","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Cedeat"},{"title":"线性DP","slug":"线性DP","date":"2022-02-10T16:00:00.000Z","updated":"2022-03-27T10:25:42.875Z","comments":true,"path":"2022/02/11/xian-xing-dp/","link":"","permalink":"http://2715992064.github.io/2022/02/11/xian-xing-dp/","excerpt":"","text":"线性DP数字三角形用f[i] [j]表示走到f[i] [j]的最大步数，一共只有两种走法，左上方走下来或右上方走下来，因此我们可以列出状态转移方程 f[i][j] = f[i - 1][j - 1] + a[i][j]; //左上方走下来 f[i][j] = f[i - 1][j] + a[i][j]; //右上方走下来 所以我们只要找到所有点的走法的最大值，再枚举最后一行，也就是出口处的最大值，就是整个三角型的最大值。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=510,INF=0x3f3f3f3f; int f[N][N]; int a[N][N]; int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=i;j++){ cin&gt;&gt;a[i][j]; } } for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;=i+1;j++){ //因为有负数，所以应该将两边也设为-INF f[i][j]=-INF; } } f[1][1]=a[1][1]; for(int i=2;i&lt;=n;i++){ for(int j=1;j&lt;=i;j++){ f[i][j]=a[i][j]+max(f[i-1][j-1],f[i-1][j]); } } int res=-INF; for(int i=1;i&lt;=n;i++) res=max(res,f[n][i]); cout&lt;&lt;res&lt;&lt;endl; } 逆序写法，更简单 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 510; int f[N][N]; int n; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= i; j ++ ){ cin &gt;&gt; f[i][j]; } } for (int i = n; i &gt;= 1; i -- ){ for (int j = i; j &gt;= 1; j -- ){ f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + f[i][j]; } } cout &lt;&lt; f[1][1] &lt;&lt; endl; // 自下向上一路选最大值选出来的 return 0; } 最长上升子序列状态表示 ：f[i] 为以i为结尾的最长的上升序列。 状态转移方程 if (w[i] &gt; w[j]) f[i] = max(f[i], f[j] + 1); 对于每个i，我们都枚举所有小于w[i]的w[j]，找出最大的小于w[i]的以w[j]为结尾的f[j]。但最后的点不一定是最大的点，我们还需要遍历一遍，找到f[i]的最大值。 #include &lt;iostream&gt; using namespace std; const int N = 1010; int n; int w[N], f[N]; int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; w[i]; int mx = 1; // 找出所计算的f[i]之中的最大值，边算边找 for (int i = 0; i &lt; n; i++) { f[i] = 1; // 设f[i]默认为1，找不到前面数字小于自己的时候就为1 for (int j = 0; j &lt; i; j++) { if (w[i] &gt; w[j]) f[i] = max(f[i], f[j] + 1); // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1 } mx = max(mx, f[i]); } cout &lt;&lt; mx &lt;&lt; endl; return 0; } 这是一个O(n^2)的做法，对于过大的数据仍然会超时。 优化（DP+二分）状态表示：f[i]表示长度为i的单调增子序列中最后一位最小的数字。 如果当前的w[i]比f[cnt - 1]大，说明满足一个单调增的序列，就将他变成当前序列的最后一个数（不一定是最小的），同时cnt++。 如果当前w[i]比f[cnt - 1]小，说明找到一个更好的序列，可以将之前的序列更新，让这个更小的数成为当前的最后一个数。 对于查找，我们可以用二分法找到第一个大于等于w[i]的数字 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 100010; int n; int a[N]; int q[N]; int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) scanf(\"%d\", &amp;a[i]); int len = 0; for (int i = 0; i &lt; n; i ++ ){ int l = 0, r = len; while (l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &gt; a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); //r存的是长度，r + 1表示r的下一个位置 q[r + 1] = a[i]; // 更新 } cout &lt;&lt; len &lt;&lt; endl; return 0; } 最长公共子序列状态划分：两个序列末尾的字符是否相等。 f[i][j] = max(f[i - 1][j], f[i][j - 1]); // 末尾字符不相等 f[i][j] = f[i - 1][j - 1] + 1; // 末尾字符相等 这里摘一下大佬的题解吧： ![`P27X0AXAE{I~$KSS1ECE56](https://s4.ax1x.com/2022/02/11/HawqHJ.png) #include &lt;iostream&gt; using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; a + 1 &gt;&gt; b + 1; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (a[i] == b[j]) { f[i][j] = f[i - 1][j - 1] + 1; } else { f[i][j] = max(f[i - 1][j], f[i][j - 1]); } } } cout &lt;&lt; f[n][m] &lt;&lt; '\\n'; return 0; } LCS+输出字符串scanf(\"%s%s\", s + 1, t + 1); //cout &lt;&lt; strlen(s + 1) &lt;&lt; ' ' &lt;&lt; strlen(t + 1) &lt;&lt; endl; for (int i = strlen(s + 1); i &gt;= 1; i -- ){ for (int j = strlen(t + 1); j &gt;= 1; j -- ){ if (s[i] == t[j]) f[i][j] = f[i + 1][j + 1] + 1; else f[i][j] = max(f[i + 1][j], f[i][j + 1]); } } int i = 1, j = 1; while (i &lt;= strlen(s + 1) &amp;&amp; j &lt;= strlen(t + 1)){ if (s[i] == t[j]){ cout &lt;&lt; s[i]; i ++; j ++; } else if (f[i][j] == f[i + 1][j]) i ++ ; else j ++; } 最短编辑距离状态表示f[i] [j] ：所有将a[1 ~ i] 变成b[1 ~ j] 的操作方式。 属性：min。 状态计算： （1）删除：若要从a中删除一个字符，则需要让f[1 ~ i - 1] 与 f[1 ~ j] 匹配，因此 f[i][j] = f[i - 1][j] + 1; （2）增加：从a中增加一个字符，需要让f[1 ~ i]与f[i ~ j - 1] 匹配 f[i][j] = f[i][j - 1] + 1; （3）修改：将f[i]改成f[j]，让前面的各位刚好匹配 f[i][j] = f[i - 1][j - 1] + 1; // f[i] != f[j] f[i][j] = f[i - 1][j - 1]; // f[i] == f[j] #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; a + 1 &gt;&gt; m &gt;&gt; b + 1; for (int i = 0; i &lt;= n; i ++ ) f[i][0] = i; for (int i = 0; i &lt;= m; i ++ ) f[0][i] = i; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= m; j ++ ){ f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 最长公共上升子序列LIS+LCS的混合问题。 状态表示： f[i] [j] 代表所有a[1 ~ i]和b[1 ~ j]中以b[j]结尾的公共上升子序列的集合；f[i] [j]的值等于该集合的子序列中长度的最大值；状态计算（对应集合划分）： 首先依据公共子序列中是否包含a[i]，将f[i] [j]所代表的集合划分成两个不重不漏的子集： 不包含a[i]的子集，最大值是f[i - 1] [j]；包含a[i]的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在b[]中是哪个数：子序列只包含b[j]一个数，长度是1；子序列的倒数第二个数是b[1]的集合，最大长度是f[i - 1] [1] + 1；…子序列的倒数第二个数是b[j - 1]的集合，最大长度是f[i - 1] [j - 1] + 1；如果直接按上述思路实现，需要三重循环： for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= n; j ++ ) { f[i][j] = f[i - 1][j]; if (a[i] == b[j]) { int maxv = 1; for (int k = 1; k &lt; j; k ++ ) if (a[i] &gt; b[k]) maxv = max(maxv, f[i - 1][k] + 1); f[i][j] = max(f[i][j], maxv); } } } #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 3010; int a[maxn], b[maxn]; int f[maxn][maxn]; int n; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= n; i ++ ){ int maxv = 1; for (int j = 1; j &lt;= n; j ++ ){ f[i][j] = f[i - 1][j]; if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv); if (a[i] &gt; b[j]) maxv = max(maxv, f[i - 1][j] + 1); } } int ans = 0; for (int i = 1; i &lt;= n; i ++ ) ans = max(ans, f[n][i]); cout &lt;&lt; ans &lt;&lt; endl; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"约数","slug":"约数","date":"2022-02-04T16:00:00.000Z","updated":"2022-02-12T09:22:03.337Z","comments":true,"path":"2022/02/05/yue-shu/","link":"","permalink":"http://2715992064.github.io/2022/02/05/yue-shu/","excerpt":"","text":"约数约数，又称因数。整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为b的倍数，b称为a的约数。 试除法求约数#include &lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; get(int n) { vector&lt;int&gt; res; for (int i = 1; i &lt;= n / i; i ++ ){ if (n % i == 0){ res.push_back(i); if (i != n / i) res.push_back(n / i); } } sort(res.begin(), res.end()); return res; } int main() { int n; cin &gt;&gt; n; while (n -- ){ int x; cin &gt;&gt; x; auto res = get(x); for (auto it : res) cout &lt;&lt; it &lt;&lt; ' '; cout &lt;&lt; endl; } return 0; } 约数个数定理对于一个大于1正整数n可以分解质因数 则n的正约数的个数就是 其中a1、a2、a3…ak是p1、p2、p3，…pk的指数。（摘自百度百科） 此处用map做一个映射，键表示约数，值表示指数，然后遵照约束个数定理计算即可。 #include &lt;bits/stdc++.h&gt; using namespace std; const int mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ){ int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ){ while (x % i == 0){ x /= i; primes[i] ++ ; } } if (x &gt; 1) primes[x] ++ ; } long long res = 1; for (auto it : primes) res = res * (it.second + 1) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0; } 约数和定理对于一个大于1正整数n可以分解质因数：n=p1^a1 * p2^a2 * p3^a3 * … * pk^ak 则由约数个数定理可知n的正约数有(a₁+1)(a₂+1)(a₃+1)…(ak+1)个， 那么n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为 f(n)=(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak） 对于每一项pn，我们可以表示为p1^a1 + p1^a1-1 …. pi^1 + 1的形式，那么对每一项，我们都让它乘a1再加1即可（秦九韶算法） #include &lt;bits/stdc++.h&gt; using namespace std; const int mod = 1e9 + 7; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ){ int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ){ while (x % i == 0){ x /= i; primes[i] ++ ; } } if (x &gt; 1) primes[x] ++ ; } long long res = 1; for (auto it : primes){ long long a = it.first, b = it.second; long long t = 1; while (b -- ){ t = (t * a + 1) % mod; } res = res * t % mod; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 最大公约数GCD计算方法：欧几里得法（辗转相除法） 递归写法： #include &lt;bits/stdc++.h&gt; using namespace std; int gcd(int a, int b) { if (b == 0) return a; else return gcd(b, a % b); } int main() { int tt; cin &gt;&gt; tt; while (tt -- ){ int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; gcd(a, b) &lt;&lt; endl; } return 0; } 拓展 最小公倍数LCM其实最小公倍数可以由最大公因数得：lcm(a, b) = a * b / gcd(a, b) 拓展欧几里得算法 EXGCD裴蜀定理对于任意的整数a，b，都一定存在整数x，y使ax+by=d，d为gcd(a,b)的倍数。 拓展欧几里得算法是在gcd递归的过程中加上x与y的迭代 设ax1+by1=gcd(a,b), bx2+(a%b)y2=gcd(b,a%b);由gcd(a,b)=gcd(b,a%b),可得:ax1+by1=bx2+(a%b)y2;即:ax1+by1=bx2+(a-(a/b)*b)y2 =ay2+bx2-(a/b) * by2;即:ax1+by1=ay2 + b(x2-(a/b) * y2)根据恒等定理,对应项相等，得:x1=y2; y1=x2-(a/b)*y2;这样我们就得到了:x1，y1的值基于x2，y2，所以我们可以通过递归求解。 #include &lt;bits/stdc++.h&gt; using namespace std; void exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b){ x = 1, y = 0; } else{ exgcd(b, a % b, y, x), y -= a / b * x; // xy互换 } } int main() { int tt; cin &gt;&gt; tt; while (tt -- ){ int a, b; cin &gt;&gt; a &gt;&gt; b; int x, y; exgcd(a, b, x, y); cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; } return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E8%AE%BA/"}],"author":"Cedeat"},{"title":"哈希表","slug":"哈希表","date":"2022-02-03T16:00:00.000Z","updated":"2022-02-12T09:20:10.141Z","comments":true,"path":"2022/02/04/ha-xi-biao/","link":"","permalink":"http://2715992064.github.io/2022/02/04/ha-xi-biao/","excerpt":"","text":"哈希表哈希表的作用将一个庞大的空间（值域）映射到比较小的空间（0-N），N一般为1e5-1e6左右。 这种映射通常使用模运算来进行，但将若干较大范围的数映射到较小范围的数，难免会发生冲突（两个数映射到同一个数上），为解决这种冲突，我们需要特殊的存储结构。 存储结构哈希表的存储结构有两种：拉链法和开放寻址法，这两者使用不同的方式处理冲突。 拉链法通过一个一维数组（0-N）来存储映射后的数，我们可以把这个数组看为一个个槽，当发生冲突时，我们会将该槽下拉一条链表，用链表存储映射到同一个槽的数据。 因此，这里我们要用到单链表的知识，将每个h[k]set为-1，表示槽指向尾节点。 插入在插入时，我们要用到单链表的头插法。 void insert(int x) { int k = (x % N + N) % N; // 避免出现模为负 e[idx] = x; ne[idx] = h[k]; h[x] = idx ++ ; } 查询bool find (int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) // 单链表的遍历操作 if (e[i] == x) return true; return false; } 开放寻址法开放寻址法不需要用到链表，只需要开一个一维数组，因此结构上看起来会更简单，但长度会更长一些（2N~3N），以此降低冲突的概率。 我们该如何处理冲突呢？对于开放寻址法，我们从前往后从h[k]开始往后寻找，如果h[k]不为空，就再往后一位寻找，直到为空为止。 find操作开放寻址法的核心是find操作 int find (int x) { int k = (x % N + N) % N; while (h[k] != null &amp;&amp; h[k] != x){ k ++ ; if (k == N) k = 0; } return k; } return k 的作用可以集查找和插入为一体，当h[k]为null时，代表为空，则会返回应插入的位置。若h[k]为x时，则代表找到x在哈希表中的位置。 有了find操作，插入和查找就变得十分简单了。 插入int k = find(x); h[k] = x; 查询if (h[k] != null) puts(\"Yes\"); else puts(\"No\"); 开放寻址法完整代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 200003, null = 0x3f3f3f3f; int h[N]; int find (int x) { int k = (x % N + N) % N; while (h[k] != null &amp;&amp; h[k] != x){ k ++; if (k == N) k = 0; } return k; } int main() { memset(h, 0x3f, sizeof(h)); int n; scanf(\"%d\", &amp;n); while (n -- ){ char op[2]; int x; scanf(\"%s %d\", op, &amp;x); if (*op == 'I') h[find(x)] = x; else{ if (h[find(x)] == null) puts(\"No\"); else puts(\"Yes\"); } } return 0; } 字符串哈希字符串哈希的实质是将不同的字符串转换为不同的整数，并且为了更方便地判断一个字符串是否出现过，仅需要O(1)的时间。 要将字符串转换为整数，我们首先要预处理出所有前缀子串的哈希值。那么如何来定义前缀的哈希值呢？ 我们通常将一个字符串看为一个P进制的数，一位字符看为一位数字。例如”ABCD”这个字符串，则可以把A当作1，B当作2，C当作3…..那么这个P进制数对应的十进制数就是1 * p^3 + 2 * p^2 + 3 * p^1 + 4 *p^0，当字符串很长时，这个十进制数会非常大，我们需要再将转化后的P进制数模上Q，以此将字符串映射为0~Q-1的数。 其中，我们需要注意不能将字符映射为0，若一个字符串“A”的哈希值为0，“AA”也为0，“AAA”同样为0，这样就会出现冲突。 当P足够好是，可以避免大部分冲突，经验之谈，当P为131或13331时， Q为2^64足够好，在大多数情况下不会出现冲突。 有了前缀的字符串哈希值，我们该如何求一个区间的字符串的哈希值呢？以字符串“ABCDEFG”为例子，令A为1，B为2，以此类推， 字符串“ABCD”的哈希值为1 * p^3 + 2 * p^2 + 3 * p^1 + 4 *p^0，而原字符串的哈希值为1 * p^6 + 2 * p^5 + 3 * p^4 + 4 * p^3 + 5 * p^2 + 6 * p^1 + 7 * p^0，若要求出字串“EFG”的哈希值，只需求出5 * p^2 + 6 * p^1 + 7 * p^0即可，通过这样表示，我们可以很清晰地看出，只需令“ABCD”的哈希值乘上一个p^3，再与原串的哈希值相减即可。 由此我们得到字串哈希值的推导公式 h[r] - h[l - 1] * p^(r - l + 1); 还记得我们前文提到的Q吗，如果我们直接使用unsigned long long 来存储所有的h，我们就不需要再进行取模操作，令其自然溢出，即相当于取2^64的模。 字符串哈希完整代码#include &lt;bits/stdc++.h&gt; using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main() { scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s\", str + 1); p[0] = 1; for (int i = 1; i &lt;= n; i ++ ){ h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } while (m -- ){ int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); if (get(l1, r1) == get(l2, r2)) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Cedeat"},{"title":"质数","slug":"质数","date":"2022-02-03T16:00:00.000Z","updated":"2022-02-12T09:22:13.212Z","comments":true,"path":"2022/02/04/zhi-shu/","link":"","permalink":"http://2715992064.github.io/2022/02/04/zhi-shu/","excerpt":"","text":"质数质数的判定-试除法质数的因子一定是成对出现的，因此不必枚举所有的因子，只要枚举其中较小的因子，也就是一半的因子即可。而较小因子的上限是sqrt(n)，所以只需到sqrt即可。 #include &lt;bits/stdc++.h&gt; using namespace std; bool is_prime(int u) { if (u &lt; 2) return false; for (int i = 2; i &lt;= u / i; i ++ ){ if (u % i == 0) return true; } return false; } int main() { int n; cin &gt;&gt; n; while (n -- ){ int x; cin &gt;&gt; x; if (is_prime(x)) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; } 分解质因数-试除法质因数是指能整除给定数的质数。同时，两个没有共同质因子的正整数称为互质。因为1没有质因子，1与任何正整数（包括1本身）都是互质。只有一个质因子的正整数为质数。 #include &lt;bits/stdc++.h&gt; using namespace std; void devide(int u) { for (int i = 2; i &lt;= u / i; i ++ ){ if (u % i == 0){ int s = 0; while (u % i == 0){ u /= i; // 分解过程 s ++ ; } printf(\"%d %d\\n\", i, s); } } if (u &gt; 1) printf(\"%d 1\\n\", u); // 一个数最多只包含一个大于sqrtn的因子，如果u还未被除尽，说明现在的u就等于这个因子 printf(\"\\n\"); } int main() { int n; cin &gt;&gt; n; while (n -- ){ int x; cin &gt;&gt; x; devide(x); } return 0; } 素数筛普通筛法（埃氏筛）素数筛与预处理相似，通过把i的倍数删去，剩余的即是素数 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N= 1000010; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i &lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i + i; j &lt;= n; j += i) st[j] = true; } } int main() { int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0; } 但埃氏筛法比较暴力，有许多数被重复筛去，增加了不必要的循环，比较多余。 线性筛法（欧拉筛法）线性筛法保证每一个合数只被筛去一次，但合数的因子可能有多个素数，对于一个数c=ab(b为c的最小质因数），当通过该算法的循环循环至c * b时，易得此时c%b==0,如果此时继续循环至b后面的一个素数d，则有：cd=a * b * d=(ad)b，因为d&gt;b,所以a * d&gt;c。当循环从c继续查找到a * d时我们发现当ad再次与素数b想乘时，就又对c * d进行了一次操作，出现了冗余，所以在if(n%prime[j]==0)成立时要将该层循环break掉； 1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]&lt;i的最小质因子,所以primes[j]*i的最小质因子就是primes[j]; 2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有最小质因子primes[j]&lt;primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此时就应该退出循环，避免之后重复进行筛选。 举个例子，对于一个数9，9 * 2=18将18标记为合数，循环继续；9 * 3=27将27标记为合数，此时发现9%3=0，循环退出。如果将循环继续下去会出现筛除9*5=45的情况，而45=15 * 3，在15时会被在筛去一次，故不可行 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N= 1000010; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int main() { int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E8%AE%BA/"}],"author":"Cedeat"},{"title":"树形DP","slug":"树状DP","date":"2022-01-04T16:00:00.000Z","updated":"2022-02-12T09:19:12.578Z","comments":true,"path":"2022/01/05/shu-zhuang-dp/","link":"","permalink":"http://2715992064.github.io/2022/01/05/shu-zhuang-dp/","excerpt":"","text":"树形DP状态表示： 树形DP的状态集合有两个f[u, 0]和f[u, 1]，分别表示所有从以u为根的子树中选择，且不选u这个点的方案，和选这个点的方案。 首先对于f[u, 0]，因为它没有选择u这个点，因此子节点自由选择，可以由f[j , 0]和f[j, 1]中转移过来，取两者最大值即可。 f[u][0] = max(f[j][1], f[j][0]); 对于f[u, 1]，由于选择了u节点，因此子节点必不能选，它等同于f[j, 0]和happy(u) f[u][1] = f[j][0] + happy[u]; 还有一点，即我们需要算完子节点，才能知道上司的情况，因此我们需要用递归的形式来做，搜索的方式可以选择dfs，同时可以给相应的f[u] [x]赋一个开心值。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 6010; int n; int h[N], e[N], ne[N], idx; int happy[N]; int f[N][2]; bool has_fa[N]; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } void dfs(int u) { f[u][1] = happy[u]; for (int i = h[u]; i != -1; i = ne[i]){ int j = e[i]; dfs(j); f[u][1] += f[j][0]; f[u][0] += max(f[j][0], f[j][1]); } } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; happy[i]; memset(h, -1, sizeof h); for (int i = 0; i &lt; n - 1; i ++ ){ int a, b; cin &gt;&gt; a &gt;&gt; b; add(b, a); has_fa[a] = true; } int root = 1; while (has_fa[root]) root ++; dfs(root); cout &lt;&lt; max(f[root][0], f[root][1]) &lt;&lt; endl; return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"状态压缩DP","slug":"状态压缩DP","date":"2022-01-04T16:00:00.000Z","updated":"2022-02-12T09:19:21.651Z","comments":true,"path":"2022/01/05/zhuang-tai-ya-suo-dp/","link":"","permalink":"http://2715992064.github.io/2022/01/05/zhuang-tai-ya-suo-dp/","excerpt":"","text":"状态压缩DP状态压缩本质上就是用一个二进制数来表示出所有的状态，从而方便用位运算节省速度。 蒙德里安的梦想要找到所有的方案数，我们需要找到所有横放1x2方格的合法方案数，当横放数量确定后，竖放的方格只需插入即可。 状态表示：用f[i] [j]记录第i列的状态j，其中状态j是用二进制表示的数，当前一位捅出来时为1，没捅出来为0。 f[i][j] = f[i - 1] [k]; //k表示能转化成j的所有合法方案。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long LL; const int N = 12, M = 1 &lt;&lt; N; int n, m; LL f[N][M]; vector&lt;int&gt; state[M]; bool st[M]; int main() { while (cin &gt;&gt; n &gt;&gt; m, n || m){ for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ){ // 预处理所有的情况 int cnt = 0; // 连续出现的0的数量 bool is_valid = true; for (int j = 0; j &lt; n; j ++ ){ if (i &gt;&gt; j &amp; 1){ // 当碰到一次1后判断之前遇见0的数量 if (cnt &amp; 1){ // 为奇数则是不合法状态 is_valid = false; break; } cnt = 0; //重新开始计算 } else cnt ++ ; } if (cnt &amp; 1) is_valid = false; // 末尾的0不会遇到1停止，最后再处理末尾的0 st[i] = is_valid; } for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ){ // 插入所有能转化成j的状态k state[i].clear(); for (int j = 0; j &lt; 1 &lt;&lt; n; j ++ ){ if ((i &amp; j) == 0 &amp;&amp; st[i | j]){ state[i].push_back(j); } } } memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i &lt;= m; i ++ ){ for (int j = 0; j &lt; 1 &lt;&lt; n; j ++ ){ for (auto k : state[j]) f[i][j] += f[i - 1][k]; } } cout &lt;&lt; f[m][0] &lt;&lt; endl; } return 0; } 最短Hamilton路径同样，状态表示f[i] [j]指走到点j的状态i的路径，同样状态i用二进制数表示， 例如走0,1,2,4这三个点,则表示为:10111;走0,2,3这三个点:1101; 状态转移方程 f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]); #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 20, M = 1 &lt;&lt; N; int f[M][N], w[N][N]; int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ){ for (int j = 0; j &lt; n; j ++ ){ cin &gt;&gt; w[i][j]; } } memset(f, 0x3f, sizeof f); f[1][0] = 0; // 初始化起点 for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ){ for (int j = 0; j &lt; n; j ++ ){ if (i &gt;&gt; j &amp; 1) // 存在j for (int k = 0; k &lt; n; k ++ ) // 走到j点之前，以k为终点的最短距离 if (i &gt;&gt; k &amp; 1) // 存在k f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]); } } cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl; return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"记忆化搜索","slug":"记忆化搜索","date":"2022-01-04T16:00:00.000Z","updated":"2022-02-12T09:18:47.537Z","comments":true,"path":"2022/01/05/ji-yi-hua-sou-suo/","link":"","permalink":"http://2715992064.github.io/2022/01/05/ji-yi-hua-sou-suo/","excerpt":"","text":"记忆化搜索记忆化搜索有点像搜索+初始化判断，通过保存过去的结果，可以避免重复的搜索，以此达到更快的时间。 f[a] [b]表示走到a，b这一点的最大距离，因此f[a] [b]如果不为初始化的值，则一定是最大值，我们不必再重复搜索 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 310; int n, m; int g[N][N]; int f[N][N]; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int dp(int x, int y) { int &amp;v = f[x][y]; if (v != - 1) return v; // 记忆化搜索，该点搜过所以不用再搜 v = 1; // 初始化 for (int i = 0; i &lt; 4; i ++ ){ int a = x + dx[i], b = y + dy[i]; if (a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; g[x][y] &gt; g[a][b]) v = max(v, dp(a , b) + 1); // 递归处理 } return v; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= m ; j ++ ){ cin &gt;&gt; g[i][j]; } } memset(f, -1, sizeof f); int res = 0; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 1; j &lt;= m; j ++ ){ res = max(res, dp(i, j)); } } cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"数位DP","slug":"数位DP","date":"2022-01-03T16:00:00.000Z","updated":"2022-02-12T09:19:15.545Z","comments":true,"path":"2022/01/04/shu-wei-dp/","link":"","permalink":"http://2715992064.github.io/2022/01/04/shu-wei-dp/","excerpt":"","text":"数位DP感觉是一种出现很多次的题然而我一次都不会（（ 数位DP的核心是分情况讨论，找到一个第j位，表示第j位上数字i出现了多少次，最后将每个位数上数字i的出现次数相加即是总和。 对于一个数abcdefg，假定第j位是d，那么有如下可能： （1）首先对于枚举的数i，如果这个数不是0，那么对于前三位abc，从0到abc，一定会有（0~999）种情况，让d为i，因此 res += l * p; （2）对于d，我们可以分成三种情况 1.d&gt;i d大于i这个数，则一定有一刻d等于i，则共有efg +1种情况 2.d=i d=i时，后三位可以为任意，则共有000~999种情况 #include &lt;bits/stdc++.h&gt; using namespace std; int dgt(int n) { int res = 0; while (n) { n /= 10; res++; } return res; } int cnt(int n, int i) { int res = 0, d = dgt(n); for (int j = 1; j &lt;= d; j ++ ){ // 分别枚举每一位上的数 int p = pow(10, j - 1), l = n / p / 10, r = n % p, dj = n / p % 10; if (i) res += l * p; if (!i &amp;&amp; l) res += (l - 1) * p; if ((dj &gt; i) &amp;&amp; (i || l)) res += p; if ((dj == i) &amp;&amp; (i || l)) res += r + 1; } return res; } int main() { int a, b; while (cin &gt;&gt; a &gt;&gt; b, a) { if (a &gt; b) swap(a, b); for (int i = 0; i &lt;= 9; i ++ ) { cout &lt;&lt; cnt(b, i) - cnt(a - 1, i) &lt;&lt; ' '; } cout &lt;&lt; endl; } return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"计数DP","slug":"计数类DP","date":"2022-01-03T16:00:00.000Z","updated":"2022-02-12T09:19:05.821Z","comments":true,"path":"2022/01/04/ji-shu-lei-dp/","link":"","permalink":"http://2715992064.github.io/2022/01/04/ji-shu-lei-dp/","excerpt":"","text":"计数类DP整数划分可看作是完全背包问题的改版，将1~n的数看作体积，每个物品使用无限次，恰好能装满背包体积n的总方案数。 注意初始化时，我们要求的与完全背包不同，完全背包要求最大的价值，该题要求最大的方案数，因此我们至少有一种方案，应该全部初始化为1。 状态表示：f[i] [j]表示使用前i个整数恰好拼成j的方案数。 因此有 f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...; f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...; 由完全背包的公式推得： f[i][j] = max(f[i][j], f[i - 1][j] + f[i][j - i]); 再加上一维优化： #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1010, mod = 1e9 + 7; int q[N]; int main() { int n; cin &gt;&gt; n; q[0] = 1; // 初始化状态为1 for (int i = 1; i &lt;= n; i ++ ){ for (int j = i; j &lt;= n; j ++ ){ q[j] = (q[j] + q[j - i]) % mod; } } cout &lt;&lt; q[n] &lt;&lt; endl; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"背包问题","slug":"背包问题","date":"2022-01-03T16:00:00.000Z","updated":"2022-03-28T10:30:45.980Z","comments":true,"path":"2022/01/04/bei-bao-wen-ti/","link":"","permalink":"http://2715992064.github.io/2022/01/04/bei-bao-wen-ti/","excerpt":"","text":"背包问题背包问题是一类很大的问题，很多问题都能转化成背包问题。 01背包01背包问题的特点是所有物品仅能用一次 状态转移方程 f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); 二维版本定义二维数组f[i] [j]表示一个状态，i标志前i个物品（有序），在背包容量为j下的最优解。 用一个二重循环迭代整个过程，外层循环i，表示前i个物品，内层循环j，表示背包容量为j下，对第i个物品是否选择。因为在同一层i的循环下，随着j的增大，f[i] [j]是不可能变小的，所以最后f[n] [m]一定是我们的最优解。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i ++ ){ for (int j = 0; j &lt;= m; j ++ ){ f[i][j] = f[i - 1][j]; // 初始化 if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 为何可以变为一维？(1) 计算f[i]时只用到了f[i - 1] (2) 在f[i]中用到的状态严格小于j 为何内层循环从大到小判断我们用到的是滚动数组，更新f[i] [j]是应该用到f[i - 1]层，但如果从小到大判断，我们用到的f[j - v[i]] 就应该是f[i] [j] 而不是f[i - 1] [j]。 优化输入在计算f[i]时其实只用到了f[i - 1]，因此我们可以边输入边进行计算： for (int i = 1; i &lt;= n; i ++ ){ int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = m; j &gt;= v; j -- ) f[j] = max(f[j], f[j - v] + w); } 最终版本#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = m; j &gt;= v; j -- ) f[j] = max(f[j], f[j - v] + w); } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 超大01背包一道思路比较清奇的题（可能是蒟蒻见识少）。 Atcoder Educational DP Contest E - Knapsack 2 题目大意：给定n个物品和一个容积为W的背包，每个物品都有一个价值v和一个质量w（与01背包要求相同），求能装下的最大价值。 该题不同的一点是数据范围，物品的质量高达了1e9，用普通的01背包，就算一维优化，也开不了这么大的数组。 该题的思路就是将价值和质量转换，令f[i]为价值为i下的最小体积（因为总价值只有1e5的范围，可以暴力枚举）。 AC代码（开longlong）： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; //#include &lt;unordered_map&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;set&gt; #include &lt;queue&gt; #include &lt;cctype&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; #define IOS \\ cin.tie(0), cout.tie(0); \\ ios::sync_with_stdio(false); #define int long long #define endl '\\n' #define x first #define y second typedef pair&lt;int, int&gt; PII; const int maxn = 200010; const int inf = 0x3f3f3f3f; const int mod = 100000007; //int h[maxn], ne[maxn], e[maxn], w[maxn], idx; int tt; int n, m; int q[maxn]; int f[maxn]; struct node { int x, y; } t[maxn]; bool cmp(node a, node b) { return a.x &lt; b.x; } void solve() { cin &gt;&gt; n &gt;&gt; m; memset(f, 0x3f, sizeof f); f[0] = 0; for (int i = 1; i &lt;= n; i ++ ){ int w, v; cin &gt;&gt; v &gt;&gt; w; for (int j = 100000; j &gt;= w; j -- ) f[j] = min(f[j], f[j - w] + v); } int ans = 0; for (int i = 1; i &lt;= 100000; i ++ ){ if (f[i] &lt;= m) ans = max(ans, i); } cout &lt;&lt; ans &lt;&lt; endl; } signed main() { IOS; tt = 1; //cin &gt;&gt; tt; while (tt -- ) solve(); return 0; } 完全背包问题完全背包问题的特点是每件物品有无限个 状态转移方程 f[i][j] = max(f[i][j], f[i][j - k * v[i]] + k * w[i]); 朴素版本 #include&lt;iostream&gt; using namespace std; const int N = 1010; int f[N][N]; int v[N],w[N]; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1 ; i &lt;= n ;i ++) { cin&gt;&gt;v[i]&gt;&gt;w[i]; } for(int i = 1 ; i&lt;=n ;i++) for(int j = 0 ; j&lt;=m ;j++) { for(int k = 0 ; k*v[i]&lt;=j ; k++) f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); } cout&lt;&lt;f[n][m]&lt;&lt;endl; } 如何优化？f[i][j] = max(f[i - 1][j] + f[i - 1][j - v] + w, f[i - 1][j - 2 * v] + 2 * w ...); f[i][j - v] = max(f[i - 1][j - v], f[i - 1][j - 2 * v] + w, ...); 因此 f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]); 加上一个一维的优化，我们就可以将三重（伪）的循环变为一维 注意我们的状态转移方程，这次用到的都是f[i]一层，因此不需要反向循环，在同一个i中可以用更新过的数据继续更新下一个，这是和01背包的不同之处。 同时，我们也可以使用优化输入，边读入边计算。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt;= n; i ++ ){ int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = v; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v] + w); } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 多重背包问题多重背包特点是每件物品最多有Si个 其实只是完全背包问题加上一个判断条件，因此可以通过朴素版的完全背包问题来修改 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i]; for (int i = 1; i &lt;= n; i ++ ) for (int j = 0; j &lt;= m; j ++ ) for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ ) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 因为是三重循环，因此时间复杂度非常高，在N=100的数据范围就进行了1000000次运算，所以局限性非常大。 在完全背包中我们使用的优化在多重背包中不能使用，原因是max不支持加减操作，在完全背包中我们只是进行了简单的代换，而在此处多了一项。 二进制优化倍增的思想：假设现在的si是1023，那么我们可以把这个1023分成10份，分别为1,2,4,8…,512，这十组里任取一个数，全部相加就可以得到0~1023中的任何一个数。所以我们可以把这几组当作01背包处理，每次选或不选。 凑出Si设Si，接着从1到2^k，2^k是小于Si的最大的2的倍数，设定一个c用来凑齐Si，即12^k可以表示出02^k+1的所有数，加上c后可以表示出cSi的所有数，将两集合合并，即可得到0Si的所有数。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 12000, M = 2020; int n, m; int v[N], w[N]; int f[M]; int main() { cin &gt;&gt; n &gt;&gt; m; int cnt = 0; // 表示下标 for (int i = 1; i &lt;= n; i ++ ){ int a, b, s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; // 幂次 while (k &lt;= s){ cnt ++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; } if (s &gt; 0){ // 表示有c的存在 cnt ++ ; v[cnt] = a * s; w[cnt] = b * s; } } n = cnt; for (int i = 1; i &lt;= n; i ++ ){ for (int j = m; j &gt;= v[i]; j -- ){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 单调队列优化能比二进制优化处理更多的数据，也比较好写（ #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 20010; int n, m; int f[N], g[N], q[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof f); for (int j = 0; j &lt; v; j ++ ) { int hh = 0, tt = -1; for (int k = j; k &lt;= m; k += v) { if (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ; while (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ; q[ ++ tt] = k; f[k] = g[q[hh]] + (k - q[hh]) / v * w; } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 分组背包问题分组背包问题的特点是物品有N组，每组里只能选一个物品。 和完全背包问题类似。 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ cin &gt;&gt; s[i]; for (int j = 0; j &lt; s[i]; j ++ ){ cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; } } for (int i = 1; i &lt;= n; i ++ ){ for (int j = m; j &gt;= 0; j -- ){ for (int k = 0; k &lt; s[i]; k ++ ){ if (v[i][k] &lt;= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0; } 二维费用的背包问题其实二维费用的背包问题和一维费用十分相似，只需要将状态表示多一维即可。 二维费用的01背包问题模板： #include &lt;iostream&gt; using namespace std; const int maxn = 1010; int n, V, M; int f[maxn][maxn]; // 表示不超过i的第一费用，j的第二费用的最大价值。 int main() { cin &gt;&gt; n &gt;&gt; V &gt;&gt; M; for (int i = 1; i &lt;= n; i ++ ){ int v, m, w; cin &gt;&gt; v &gt;&gt; m &gt;&gt; w; for (int j = V; j &gt;= v; j -- ){ for (int k = M; k &gt;= m; k -- ){ f[j][k] = max(f[j][k], f[j - v][k - m] + w); } } } cout &lt;&lt; f[V][M] &lt;&lt; endl; } 可见，二维费用的背包问题和一维费用背包问题的最大区别是状态表示多一维，且多加一个循环用于表示另外一重费用。","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"区间DP","slug":"区间DP","date":"2022-01-02T16:00:00.000Z","updated":"2022-02-12T09:19:10.546Z","comments":true,"path":"2022/01/03/qu-jian-dp/","link":"","permalink":"http://2715992064.github.io/2022/01/03/qu-jian-dp/","excerpt":"","text":"区间DP区间DP的核心是每次都将左边一堆与右边连续的一堆合并 状态表示：f[i] [j]表示将i到j合并为一堆的方案的集合的最小值。 状态计算： f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]); // i &lt; j f[i][j] = 0; // i == j 所有的区间dp问题，第一维都是枚举区间长度，一般 len = 1 用来初始化，枚举从 len = 2 开始，第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1） for (int i = 1; i &lt;= n; i++) { dp[i][i] = 初始值 } for (int len = 2; len &lt;= n; len++) //区间长度 for (int i = 1; i + len - 1 &lt;= n; i++) { //枚举起点 int j = i + len - 1; //区间终点 for (int k = i; k &lt; j; k++) { //枚举分割点，构造状态转移方程 dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]); } } #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 307; int a[N], s[N]; int f[N][N]; int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++ ){ cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; } for (int len = 1; len &lt;= n; len ++ ){ // 枚举所有长度 for (int i = 1; i + len &lt;= n; i ++ ){ int j = i + len; // 右端点 f[i][j] = 1e8; // 初始化成大数，防止取到0 for (int k = i; k &lt;= j - 1; k ++ ){ // 枚举区间所有可能的k，找到最小值 f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]); } } } cout &lt;&lt; f[1][n] &lt;&lt; endl; return 0; } 时间复杂度O(n ^3)","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Cedeat"},{"title":"拓扑排序","slug":"拓扑排序","date":"2021-12-23T16:00:00.000Z","updated":"2022-02-12T09:21:07.527Z","comments":true,"path":"2021/12/24/tuo-bu-pai-xu/","link":"","permalink":"http://2715992064.github.io/2021/12/24/tuo-bu-pai-xu/","excerpt":"","text":"拓扑排序什么是拓扑排序？若一个由图中所有点构成的序列A没满足：对于图中的每条边(x,y)，x在A中都出现在y之前，则称A是该图中的一个拓扑排序。只适用于有向无环图（AOV网）。 入度想要找到拓扑排序，我们要了解入度的概念：指有向图中某点作为图中边的终点的次数之和。 对于一个入度为零的点，即没有任何一个点指向该点，我们可以认为这个点在拓扑排序中处于顶点的位置。我们可以维护一个队列，将这些入度为零的点入队，此时这些点就已经有序，不需要再入队，即可将该点删除，即将它指向的下一个点的入度减一，然后再次寻找入度为零的点即可，这样，我们就构成了一个循环。 如何判断该图是否存在合法的拓扑序列呢？我们可以由定义得到，合法的拓扑序列，一定由图中所有点共同构成，因此只要队列中进入过n次元素，即可判断存在一个合法的序列。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int N = 1e5 + 10; int e[N],ne[N],h[N],idx,d[N],n,m,top[N],cnt = 1; // e,ne,h,idx 邻接表模板 // d 代表每个元素的入度 // top是拓扑排序的序列，cnt代表top中有多少个元素 void add(int a,int b){ e[idx] = b; ne[idx] = h[a]; h[a] = idx ++; } bool topsort(){ queue&lt;int&gt; q; int t; for(int i = 1;i &lt;= n; ++i)// 将所有入度为0的点加入队列 if(d[i] == 0) q.push(i); while(q.size()){ t = q.front();//每次取出队列的首部 top[cnt] = t;//加入到 拓扑序列中 cnt ++; // 序列中的元素 ++ q.pop(); for(int i = h[t];i != -1; i = ne[i]){ // 遍历 t 点的出边 int j = e[i]; d[j] --;// j 的入度 -- if(d[j] == 0) q.push(j); //如果 j 入度为0，加入队列当中 } } if(cnt &lt; n) return 0; else return 1; } int main(){ int a,b; cin &gt;&gt; n &gt;&gt; m; memset(h,-1,sizeof h); while(m--){ cin &gt;&gt; a &gt;&gt; b; add(a,b); d[b] ++;// a -&gt; b , b的入度++ } if(topsort() == 0) cout &lt;&lt; \"-1\"; else { for(int i = 1;i &lt;= n; ++i){ cout &lt;&lt; top[i] &lt;&lt;\" \"; } } return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论/搜索","slug":"图论-搜索","permalink":"http://2715992064.github.io/tags/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2/"}],"author":"Cedeat"},{"title":"DOS命令","slug":"DOS命令","date":"2021-12-16T16:00:00.000Z","updated":"2022-02-12T09:22:35.887Z","comments":true,"path":"2021/12/17/dos-ming-ling/","link":"","permalink":"http://2715992064.github.io/2021/12/17/dos-ming-ling/","excerpt":"","text":"DOS命令cd 目录名 进入特定的目录 cd\\ 退回根目录 cd .. 退回上一级 dir 显示目录文件和子目录列表。 md 目录名 在该目录下新建文件夹 rd 目录名 删除特定文件夹 del 文件名 删除特定文件 del ***.** *删除文件夹下所有文件 del *xxx 删除文件名中含xxx的文件","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://2715992064.github.io/tags/%E5%85%B6%E5%AE%83/"}],"author":"Cedeat"},{"title":"深度优先搜索","slug":"DFS","date":"2021-12-15T16:00:00.000Z","updated":"2022-02-19T08:04:31.457Z","comments":true,"path":"2021/12/16/dfs/","link":"","permalink":"http://2715992064.github.io/2021/12/16/dfs/","excerpt":"","text":"DFS（深度优先搜索）DFS使用栈的数据结构，指对所有可能的分支进行一次搜索，优先向下走，直到不能搜索为止，当搜索到头没有路时进行回溯，或在不满足条件时剪枝，然后再次找到别的路径深入。它所找到的不一定是最短路。 全排列问题#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 10; int n; int path[N]; bool st[N]; // 判断数字是否用过 void dfs(int u) { if (u == n){ for (int i = 0; i &lt; n; i ++ ) printf(\"%d \", path[i]); // 走到结尾，输出 printf(\"\\n\"); return ; // 回溯到上一层 } for (int i = 1; i &lt;= n; i ++ ){ // 用来表示用到的数字 if (!st[i]){ path[u] = i; st[i] = true; dfs(u + 1); // 往下寻找 st[i] = false; // 恢复现场 } } } int main() { cin &gt;&gt; n; dfs(0); // 从头开始 } n皇后问题#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 20; int n; bool col[N], dg[N], udg[N];//col表示宗行,dg为正对角线，udg为反对角线 char g[N][N]; void dfs(int u) { if (u == n){ for (int i = 0; i &lt; n; i ++ ) printf(\"%s\", g[i]); printf(\"\\n\"); return ; } for (int i = 1; i &lt;= n; i ++ ){ if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]){ // 剪枝，不满足条件则不往后走 g[u][i] = 'Q'; col[i] = dg[u + i] = udg[n - u + i] = true; dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; g[u][i] = '.'; } } } int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ){ for (int j = 0; j &lt; n; j ++ ){ g[i][j] = '.'; } } dfs(0); return 0; } n皇后问题与全排列本质相同，因为每一行必定有一个皇后，我们列举皇后在每一列可能的情况。","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论/搜索","slug":"图论-搜索","permalink":"http://2715992064.github.io/tags/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2/"}],"author":"Cedeat"},{"title":"宽度优先搜索","slug":"BFS","date":"2021-12-15T16:00:00.000Z","updated":"2022-02-12T09:21:21.017Z","comments":true,"path":"2021/12/16/bfs/","link":"","permalink":"http://2715992064.github.io/2021/12/16/bfs/","excerpt":"","text":"BFS（宽度优先搜索）宽度优先搜索最大的优势是可以搜索到最短路，然而在空间上要比DFS上大一些。BFS是一层一层向外搜索，先搜索所有距离为1的点，再搜索所有距离为2的点，以此类推，所以搜到的点是逐渐离我们越来越远的，找到的第一个即为最小，前提是图的边的权重都为1。 走迷宫#include &lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 110; int n, m; int g[N][N], d[N][N]; // g用于读取地图，d兼具判重和计算长度两种功能。 int bfs() { queue &lt;PII&gt; q; // 用队列存储每一次走到的点 memset(d, -1, sizeof d); // 初始化，用于后续判重. d[0][0] = 0; // 原点的距离是0. q.push({0, 0}); // 以原点开始查找 int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; // 表示该点向四个方向走的可能的情况。 while (q.size()){ auto t = q.front(); // 每次取出队头的点，进行四个方向的查找 q.pop(); // 将队列中的该点删除. for (int i = 0; i &lt; 4; i ++ ){ int x = t.first + dx[i], y = t.second + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1){ // 找到符合条件的点。 d[x][y] = d[t.first][t.second] + 1; // 用该点存放距离，t里的点为上次的点，表示从t点走到（x，y）这个点，因此距离加一。 q.push({x, y}); // 将该点推入队列，等待继续往后走. } } } return d[n - 1][m - 1]; // 返回最后一点的距离。 } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0 ; i &lt; n; i ++ ){ for (int j = 0; j &lt; m; j ++ ){ cin &gt;&gt; g[i][j]; // 读入地图 } } cout &lt;&lt; bfs() &lt;&lt; endl; return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论/搜索","slug":"图论-搜索","permalink":"http://2715992064.github.io/tags/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2/"}],"author":"Cedeat"},{"title":"并查集","slug":"并查集","date":"2021-12-14T04:14:00.000Z","updated":"2022-02-12T09:19:46.912Z","comments":true,"path":"2021/12/14/bing-cha-ji/","link":"","permalink":"http://2715992064.github.io/2021/12/14/bing-cha-ji/","excerpt":"","text":"并查集并查集的作用1.进行集合合并。 2.查询两个元素是否处于同一集合。 并查集的原理用树的形式维护所有的集合 每个集合用一颗树来标志。树的编号就是整个集合的编号。每个节点储存的是他的父节点，p[x]表示x的父节点。 例： 对于一个元素3，若p[3] = 5，则表示3属于编号为5的这个集合当中。 并查集的实现方式（基础操作）1.如何判断树根if (p[x] == x) 2.如何求x的集合编号while (p[x] != x) x = p[x]; 每次找节点试都要重新往上找一边，时间复杂度很高，可以进行路线压缩优化。 路线压缩：即找到集合的根节点后，令集合的所有元素指向根结点，以便进行下次查找。 int find (int x) // 返回x的集合编号（祖宗节点） + 路径压缩 { if (p[x] != x) p[x] = find(p[x]); return p[x];// 递归方法实现，只有p[x] == x时，即x为祖宗节点时才会返回，令调用过程中所有的p[x]都等于祖宗节点的值。 } 3.如何合并两个集合p[x] = y;//p[x]为x的集合编号，p[y]为y的集合编号。 p[find(a)] = find(b) || p[find(a)] = p[find(b)] // 因为find(b)即祖宗节点，所以p[find(b)] == find(b)，两者含义相同。 完整代码#include &lt;iostream&gt; using namespace std; const int N = 100010; int p[N]; int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; while (m -- ) { char op[2]; int a, b; scanf(\"%s%d%d\", op, &amp;a, &amp;b); if (*op == 'M') p[find(a)] = find(b); else { if (find(a) == find(b)) puts(\"Yes\"); else puts(\"No\"); } } return 0; }","categories":[{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"算法进阶","slug":"算法进阶","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"},{"name":"算法入门","slug":"算法入门","permalink":"http://2715992064.github.io/categories/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://2715992064.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"搜索","slug":"搜索","permalink":"http://2715992064.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://2715992064.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论/搜索","slug":"图论-搜索","permalink":"http://2715992064.github.io/tags/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2/"},{"name":"数论","slug":"数论","permalink":"http://2715992064.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"其它","slug":"其它","permalink":"http://2715992064.github.io/tags/%E5%85%B6%E5%AE%83/"}]}