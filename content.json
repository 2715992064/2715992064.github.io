{"meta":{"title":"爱吃香菜","subtitle":"Lets Cedeatttttttttttt~~","description":"编程小白的记录，来看看吧~","author":"Cedeat","url":"http://2715992064.github.io","root":"/"},"pages":[{"title":"404","date":"2021-09-27T12:43:30.000Z","updated":"2021-09-27T12:43:56.464Z","comments":true,"path":"404/index.html","permalink":"http://2715992064.github.io/404/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-12-13T15:41:56.000Z","updated":"2021-12-13T15:41:56.748Z","comments":true,"path":"tags/index.html","permalink":"http://2715992064.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"堆","date":"2021-12-13T14:40:46.153Z","updated":"2021-12-13T14:40:23.462Z","comments":true,"path":"2021/12/13/堆/","link":"","permalink":"http://2715992064.github.io/2021/12/13/%E5%A0%86/","excerpt":"","text":"堆堆的结构：一颗完全二叉树（十分平衡，除最后一层（叶结点）以外，其他节点均非空，最后一层从左到右依次排布）。 小根堆也指最小堆。经过排序的完全二叉树，其中每一个非终端节点均小于其左右子节点，其根节点为所有元素的最小值。 大根堆同理。 存储方式用一维数组维护堆状数据结构。 一号点为根节点。下标为x的节点，其左节点下标为2 * x，右节点下标为2 * x + 1。 基本操作1.向下调整（down操作）:若将一个数变大，则须将这个节点下移。以小根堆为例，将一个节点下移，则需要判断它与左右子节点的大小关系，并将它与（自己，左节点，右节点）三个数中的最小值交换。 1234567891011void down(int u)&#123; int t = u; // 定义t，用来寻找三个数中最小值的下标。 if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[u]) t = u * 2; // 判断左节点是否存在，且左节点是否更小。 if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[u]) t = u * 2 + 1; // 同上，判断右节点。 if (t != u) // 需要操作 &#123; swap(h[u], h[t]); down (t); // 递归操作，直到u为当前三个数的最小值。 &#125;&#125; 2.向上调整（up操作）：同理，要将一个数变小，则需将这个节点上移，对于小根堆，上移操作仅需跟它的父节点比较即可。 1234567void up(int u)&#123; while (u / 2 &amp;&amp; h[u / 2] &gt; h[u])&#123; swap(h[u / 2], h[u]); u /= 2; &#125;// 迭代操作，当为头节点或不能再向上时结束。&#125; 3.插入一个数：将该数插入到整个堆的最后一个位置，然后进行up操作。 1heap[++ size] = x; up(size); 4.删除任意一个元素：对于一维数组，删除数组的尾部非常简单，令size–即可，但若要删除中间元素，则需要整体改变下标的位置。 假设我们现在要删除第k个节点，只需将第k个节点变为最后一个节点，然后再删除最后一个节点。最后，对k节点进行down操作或up操作（因为此处第k个节点被赋给了最后一个结点的值），为了不用再进行判断，我们让k节点都进行up和down操作（不用担心会额外进行操作，当满足条件时，up操作和down操作只会执行其一）。 1heap[k] = heap[size]; size -- ; down(k); up(k);// 删除头节点，将K改为1即可。 5.求集合中的最小（大）值：对堆来说，最值即为根结点。 1heap[1]; //大根堆为最大值，小根堆为最小值。 6.修改任意一个元素：将要修改的元素（k节点）修改后，再进行一次up操作和down操作。 1heap[k] = x; down(k); up(k); 7.堆的构建如果我们将n个元素每个都进行一次down操作，则时间复杂度为O（nlogn），也可通过优化，将复杂度改为O(n)。 堆的最后一层至多有n / 2个元素，如果我们要对所有元素进行down操作，则只需要对倒数第二层以上进行down操作，在对倒数第二层进行down操作时，也会保证处理到最后一层的元素，这样，我们就只须处理n / 2个数据，时间复杂度变为O(n)。 1for (int i = n / 2; i ; i -- ) down(i); 进阶：堆的映射：当我们把上述所提到的删除和修改第K个节点改为删除和修改第K个插入的数，就会变成更复杂的情况。 在这里我们需要额外开两个数组ph[N]和hp[N]，ph[k]用来存储第k个插入的数在堆中的下标，但仅有此并不够，当我们在进行up或down操作时，堆中的值会改变。 举个例子，当第5个插入的数在堆中的下标为3，其子节点在堆中的下标为6。那么ph[5]即为3，但此时小根堆是不稳定的，如果我们要进行一次down操作，会将heap[3]和heap[6]的值进行交换，此时第5个插入的数，即ph[5]就会改变。一句话来说，单单用ph数组对堆进行映射是单向的关系。 为了解决这种情况，我们另设一个数组hp[N]用来表示，第k个插入的数在堆中的下标在ph数组中的值。也就是说，用此数组将堆中的下标映射与ph数组，从而达到双向的关系。 ph数组与hp数组互为反函数。即ph[j] = k, hp[k] = j; 有这两个工具，我们就可以将down和up操作中的swap函数进行“升级”，即不仅仅改变堆中的两个值，他们所对应的插入关系也应该交换。 123456void heap_swap(int a, int b)&#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125; 堆排序完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int n, m;int h[N], cnt;void down(int u)&#123; int t = u; if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t)&#123; swap(h[u], h[t]); down(t); &#125;&#125;void up (int u)&#123; while (u / 2 &amp;&amp; h[u / 2] &gt; h[u])&#123; swap(h[u], h[u / 2]); u &gt;&gt;= 1; &#125; &#125;int main()&#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]); cnt = n; for (int i = n / 2; i ; i --) down(i); while (m -- )&#123; printf(&quot;%d &quot;, h[1]); h[1] = h[cnt -- ]; down(1); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"","slug":"并查集","date":"2021-12-12T14:31:01.662Z","updated":"2021-12-13T08:16:22.463Z","comments":true,"path":"2021/12/12/并查集/","link":"","permalink":"http://2715992064.github.io/2021/12/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集的作用1.进行集合合并。 2.查询两个元素是否处于同一集合。 并查集的原理用树的形式维护所有的集合 每个集合用一颗树来标志。树的编号就是整个集合的编号。每个节点储存的是他的父节点，p[x]表示x的父节点。 例： 对于一个元素3，若p[3] = 5，则表示3属于编号为5的这个集合当中。 并查集的实现方式（基础操作）1.如何判断树根1if (p[x] == x) 2.如何求x的集合编号1while (p[x] != x) x = p[x]; 每次找节点试都要重新往上找一边，时间复杂度很高，可以进行路线压缩优化。 路线压缩：即找到集合的根节点后，令集合的所有元素指向根结点，以便进行下次查找。 12345int find (int x) // 返回x的集合编号（祖宗节点） + 路径压缩&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];// 递归方法实现，只有p[x] == x时，即x为祖宗节点时才会返回，令调用过程中所有的p[x]都等于祖宗节点的值。&#125; 3.如何合并两个集合12p[x] = y;//p[x]为x的集合编号，p[y]为y的集合编号。p[find(a)] = find(b) || p[find(a)] = p[find(b)] // 因为find(b)即祖宗节点，所以p[find(b)] == find(b)，两者含义相同。 完整代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int N = 100010;int p[N];int find(int x)&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; while (m -- ) &#123; char op[2]; int a, b; scanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b); if (*op == &#x27;M&#x27;) p[find(a)] = find(b); else &#123; if (find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"","slug":"ZZULIOJ 1009 求平均分","date":"2021-10-02T04:09:46.085Z","updated":"2021-09-26T13:56:52.603Z","comments":true,"path":"2021/10/02/ZZULIOJ 1009 求平均分/","link":"","permalink":"http://2715992064.github.io/2021/10/02/ZZULIOJ%201009%20%E6%B1%82%E5%B9%B3%E5%9D%87%E5%88%86/","excerpt":"","text":"ZZULIOJ 1009: 求平均分代码示例112345678910111213#include&lt;stdio.h&gt; int main()&#123;int ch, ma ,en; scanf(&quot;%d%d%d&quot;, &amp;ch, &amp;ma, &amp;en);//输入三个学科的成绩 double average = (ch + ma + en) / 3.0;//求平均 printf(&quot;%.2f\\n&quot;, average);return 0;&#125; 212345678910111213#include&lt;stdio.h&gt; int main()&#123;int ch, ma ,en; scanf(&quot;%d%d%d&quot;, &amp;ch, &amp;ma, &amp;en);//输入三个学科的成绩 double average = (ch + ma + en) / 3;//求平均 printf(&quot;%.2f\\n&quot;, average);return 0;&#125; 易错点 以上两串代码有何区别？你会发现，在求平均过程中，分母分别为3.0和3。 3=3.0，我们可能会觉得两个式子是没有区别的，但在编译器里进行计算后，我们发现两代码计算出的值并不相同，这是为什么呢？ 因为本题的原因，我们求平均值的三个数据（成绩）都为整数型，而分母（学科数目）也为整数型，以此计算，就算我们算出的数是一个小数，也是会先表示成整数类型，再在求平均过程中升级为浮点类型。 以程序2为例，假如求平均赋值过程中右侧的结果为84.3333….，因为分子分母均为整数类型，结果会变为整数类型84，在赋值给左侧average转化为双精度浮点型，最后输出为84.00，与原结果并不相等。 因此在程序1中，我们将分母变为3.0，相当于默认=右侧数据为浮点数，因此小数点后的数据得以保留，与原结果相等。 当然，令数据转为浮点型的方式不只有一种，在式子前或后*1.0也可以，如果我们给出的数据（例如本题中的成绩）已经是浮点数了，那么就不用再转换了。","categories":[],"tags":[]},{"title":"","slug":"ZZULIOJ 1000 从今天开始入坑C语言","date":"2021-10-02T04:09:46.084Z","updated":"2021-09-26T14:24:55.348Z","comments":true,"path":"2021/10/02/ZZULIOJ 1000 从今天开始入坑C语言/","link":"","permalink":"http://2715992064.github.io/2021/10/02/ZZULIOJ%201000%20%E4%BB%8E%E4%BB%8A%E5%A4%A9%E5%BC%80%E5%A7%8B%E5%85%A5%E5%9D%91C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"ZZULIOJ 1000:从今天开始入坑C语言代码123456#include&lt;stdio.h&gt;//引入头文件int main()//定义主函数为int类型&#123; printf(&quot;从今天开始入坑C语言\\n&quot;);//输出指定内容，\\n为换行符号 return 0;//函数返回值&#125; 这是一个C语言的标准格式，将会伴随我们走过整个C语言学习过程。 (1)int main(void)与int main()不同，但在多数代码中无区别。其不同之处是int main()可在引用时传入参数，int main(void)不可以。两者都需要返回值。 (2)void main()虽然也有相同的效果，但 void main()不需要返回值，且在某些编译器中代码会报错，因此并不推荐这种写法。","categories":[],"tags":[]}],"categories":[],"tags":[]}