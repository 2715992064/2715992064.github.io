{"meta":{"title":"爱吃香菜","subtitle":"Lets Cedeatttttttttttt~~","description":"编程小白的记录，来看看吧~","author":"Cedeat","url":"http://2715992064.github.io","root":"/"},"pages":[{"title":"404","date":"2021-09-27T12:43:30.000Z","updated":"2021-09-27T12:43:56.464Z","comments":true,"path":"404/index.html","permalink":"http://2715992064.github.io/404/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"并查集","date":"2021-12-12T14:31:01.662Z","updated":"2021-12-13T08:16:22.463Z","comments":true,"path":"2021/12/12/并查集/","link":"","permalink":"http://2715992064.github.io/2021/12/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集的作用1.进行集合合并。 2.查询两个元素是否处于同一集合。 并查集的原理用树的形式维护所有的集合 每个集合用一颗树来标志。树的编号就是整个集合的编号。每个节点储存的是他的父节点，p[x]表示x的父节点。 例： 对于一个元素3，若p[3] = 5，则表示3属于编号为5的这个集合当中。 并查集的实现方式（基础操作）1.如何判断树根1if (p[x] == x) 2.如何求x的集合编号1while (p[x] != x) x = p[x]; 每次找节点试都要重新往上找一边，时间复杂度很高，可以进行路线压缩优化。 路线压缩：即找到集合的根节点后，令集合的所有元素指向根结点，以便进行下次查找。 12345int find (int x) // 返回x的集合编号（祖宗节点） + 路径压缩&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];// 递归方法实现，只有p[x] == x时，即x为祖宗节点时才会返回，令调用过程中所有的p[x]都等于祖宗节点的值。&#125; 3.如何合并两个集合12p[x] = y;//p[x]为x的集合编号，p[y]为y的集合编号。p[find(a)] = find(b) || p[find(a)] = p[find(b)] // 因为find(b)即祖宗节点，所以p[find(b)] == find(b)，两者含义相同。 完整代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int N = 100010;int p[N];int find(int x)&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; while (m -- ) &#123; char op[2]; int a, b; scanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b); if (*op == &#x27;M&#x27;) p[find(a)] = find(b); else &#123; if (find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"","slug":"ZZULIOJ 1009 求平均分","date":"2021-10-02T04:09:46.085Z","updated":"2021-09-26T13:56:52.603Z","comments":true,"path":"2021/10/02/ZZULIOJ 1009 求平均分/","link":"","permalink":"http://2715992064.github.io/2021/10/02/ZZULIOJ%201009%20%E6%B1%82%E5%B9%B3%E5%9D%87%E5%88%86/","excerpt":"","text":"ZZULIOJ 1009: 求平均分代码示例112345678910111213#include&lt;stdio.h&gt; int main()&#123;int ch, ma ,en; scanf(&quot;%d%d%d&quot;, &amp;ch, &amp;ma, &amp;en);//输入三个学科的成绩 double average = (ch + ma + en) / 3.0;//求平均 printf(&quot;%.2f\\n&quot;, average);return 0;&#125; 212345678910111213#include&lt;stdio.h&gt; int main()&#123;int ch, ma ,en; scanf(&quot;%d%d%d&quot;, &amp;ch, &amp;ma, &amp;en);//输入三个学科的成绩 double average = (ch + ma + en) / 3;//求平均 printf(&quot;%.2f\\n&quot;, average);return 0;&#125; 易错点 以上两串代码有何区别？你会发现，在求平均过程中，分母分别为3.0和3。 3=3.0，我们可能会觉得两个式子是没有区别的，但在编译器里进行计算后，我们发现两代码计算出的值并不相同，这是为什么呢？ 因为本题的原因，我们求平均值的三个数据（成绩）都为整数型，而分母（学科数目）也为整数型，以此计算，就算我们算出的数是一个小数，也是会先表示成整数类型，再在求平均过程中升级为浮点类型。 以程序2为例，假如求平均赋值过程中右侧的结果为84.3333….，因为分子分母均为整数类型，结果会变为整数类型84，在赋值给左侧average转化为双精度浮点型，最后输出为84.00，与原结果并不相等。 因此在程序1中，我们将分母变为3.0，相当于默认=右侧数据为浮点数，因此小数点后的数据得以保留，与原结果相等。 当然，令数据转为浮点型的方式不只有一种，在式子前或后*1.0也可以，如果我们给出的数据（例如本题中的成绩）已经是浮点数了，那么就不用再转换了。","categories":[],"tags":[]},{"title":"","slug":"ZZULIOJ 1000 从今天开始入坑C语言","date":"2021-10-02T04:09:46.084Z","updated":"2021-09-26T14:24:55.348Z","comments":true,"path":"2021/10/02/ZZULIOJ 1000 从今天开始入坑C语言/","link":"","permalink":"http://2715992064.github.io/2021/10/02/ZZULIOJ%201000%20%E4%BB%8E%E4%BB%8A%E5%A4%A9%E5%BC%80%E5%A7%8B%E5%85%A5%E5%9D%91C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"ZZULIOJ 1000:从今天开始入坑C语言代码123456#include&lt;stdio.h&gt;//引入头文件int main()//定义主函数为int类型&#123; printf(&quot;从今天开始入坑C语言\\n&quot;);//输出指定内容，\\n为换行符号 return 0;//函数返回值&#125; 这是一个C语言的标准格式，将会伴随我们走过整个C语言学习过程。 (1)int main(void)与int main()不同，但在多数代码中无区别。其不同之处是int main()可在引用时传入参数，int main(void)不可以。两者都需要返回值。 (2)void main()虽然也有相同的效果，但 void main()不需要返回值，且在某些编译器中代码会报错，因此并不推荐这种写法。","categories":[],"tags":[]}],"categories":[],"tags":[]}